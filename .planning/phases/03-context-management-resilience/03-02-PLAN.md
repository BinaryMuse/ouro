---
phase: 03-context-management-resilience
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/agent/context_manager.rs
  - src/agent/mod.rs
autonomous: true

must_haves:
  truths:
    - "ContextManager tracks token usage and returns the correct ContextAction for each threshold zone"
    - "Observation masking replaces tool output content with summary placeholders while preserving message structure"
    - "Character-count fallback activates when token usage data is unavailable"
  artifacts:
    - path: "src/agent/context_manager.rs"
      provides: "ContextManager struct with token tracking, threshold evaluation, observation masking"
      contains: "pub struct ContextManager"
    - path: "src/agent/context_manager.rs"
      provides: "ContextAction enum (Continue, Mask, WindDown, Restart)"
      contains: "pub enum ContextAction"
    - path: "src/agent/mod.rs"
      provides: "context_manager module declaration"
      contains: "pub mod context_manager"
  key_links:
    - from: "src/agent/context_manager.rs"
      to: "src/config/schema.rs"
      via: "ContextManager::new takes AppConfig fields"
      pattern: "context_limit.*soft_threshold"
    - from: "src/agent/context_manager.rs"
      to: "genai::chat::ChatMessage"
      via: "mask_oldest_observations mutates Vec<ChatMessage>"
      pattern: "mask_oldest.*ChatMessage"
---

<objective>
Implement the ContextManager module -- the core engine for token tracking, graduated threshold evaluation, and observation masking.

Purpose: This is the brain of Phase 3. It encapsulates all context pressure logic in a single testable struct that the agent loop will call after every turn. Observation masking is the key mechanism that extends the agent's effective context lifetime.
Output: A complete, unit-tested `context_manager.rs` with ContextManager struct, ContextAction enum, token tracking, threshold-based action decisions, and observation masking with summary placeholders.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-context-management-resilience/03-CONTEXT.md
@.planning/phases/03-context-management-resilience/03-RESEARCH.md
@src/agent/mod.rs
@src/config/schema.rs

# Prior plan provides config fields this module consumes
@.planning/phases/03-context-management-resilience/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ContextManager struct with token tracking and threshold evaluation</name>
  <files>src/agent/context_manager.rs, src/agent/mod.rs</files>
  <action>
Create `src/agent/context_manager.rs` with the following:

1. **ContextAction enum:**
```rust
pub enum ContextAction {
    Continue,
    Mask { count: usize },   // Number of observations to mask this round
    WindDown,                  // Hard threshold hit, tell agent to wrap up
    Restart,                   // Context exhausted, restart session
}
```

2. **ContextManager struct** with fields:
   - `context_limit: usize` (model's context window in tokens)
   - `soft_threshold_pct: f64` (e.g. 0.70)
   - `hard_threshold_pct: f64` (e.g. 0.90)
   - `carryover_turns: usize`
   - `prompt_tokens: usize` (from latest Ollama response -- THIS is the current context size)
   - `completion_tokens_total: usize` (cumulative across the session, for logging)
   - `total_chars: usize` (fallback character count when token data unavailable)
   - `masked_count: usize` (total observations masked so far)
   - `session_number: u32` (1-based, incremented on restart)
   - `turn_count: u64` (turns in current session)
   - `wind_down_sent: bool` (prevents sending wind-down multiple times)

3. **ContextManager::new(context_limit, soft_threshold_pct, hard_threshold_pct, carryover_turns) -> Self** -- constructor. session_number defaults to 1.

4. **ContextManager::update_token_usage(&mut self, prompt_tokens: usize, completion_tokens: usize)** -- sets prompt_tokens (NOT additive -- prompt_tokens from Ollama IS the total context size), adds completion_tokens to total. Critical: prompt_tokens from Ollama already includes the entire conversation. Do NOT sum across turns.

5. **ContextManager::add_chars(&mut self, chars: usize)** -- adds to total_chars for fallback heuristic.

6. **ContextManager::usage_percentage(&self) -> f64** -- if prompt_tokens > 0, return prompt_tokens as f64 / context_limit as f64. Otherwise fall back to (total_chars / 4) as f64 / context_limit as f64. The fallback uses the Phase 2 heuristic (1 token ~ 4 chars).

7. **ContextManager::evaluate(&mut self) -> ContextAction** -- the core decision function:
   - Let pct = self.usage_percentage()
   - If pct >= hard_threshold_pct AND wind_down_sent: return Restart
   - If pct >= hard_threshold_pct AND NOT wind_down_sent: set wind_down_sent = true, return WindDown
   - If pct >= soft_threshold_pct: calculate how many observations to mask (e.g. 3 per evaluation, tunable), return Mask { count }
   - Otherwise: return Continue

8. **ContextManager::increment_turn(&mut self)** -- bumps turn_count.

9. **ContextManager::session_number(&self) -> u32**, **turn_count(&self) -> u64**, **masked_count(&self) -> usize**, **prompt_tokens(&self) -> usize** -- getters.

10. **ContextManager::prepare_restart(&mut self)** -- increments session_number, resets prompt_tokens/completion_tokens_total/total_chars/turn_count/masked_count/wind_down_sent.

Add `pub mod context_manager;` to `src/agent/mod.rs`.

Add unit tests in the same file:
- `test_continue_when_under_soft_threshold` -- set usage to 50%, evaluate returns Continue
- `test_mask_when_at_soft_threshold` -- set usage to 75%, evaluate returns Mask
- `test_winddown_when_at_hard_threshold` -- set usage to 92%, evaluate returns WindDown, wind_down_sent becomes true
- `test_restart_after_winddown` -- call evaluate twice at hard threshold, second returns Restart
- `test_fallback_char_heuristic` -- don't set prompt_tokens, add chars, verify usage_percentage uses chars/4
- `test_prompt_tokens_not_additive` -- call update_token_usage twice, verify prompt_tokens is latest value (not summed)
  </action>
  <verify>
`cargo check` compiles cleanly.
`cargo test context_manager` passes all 6 unit tests.
  </verify>
  <done>
ContextManager struct exists with token tracking, graduated threshold evaluation, and char-count fallback. All 6 unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement observation masking with summary placeholders</name>
  <files>src/agent/context_manager.rs</files>
  <action>
Add observation masking functions to `context_manager.rs`:

1. **Placeholder marker constant:** `const MASKED_MARKER: &str = "[masked]";` -- used to detect already-masked observations.

2. **generate_placeholder(fn_name: &str, original_content: &str) -> String** -- creates a summary placeholder:
   - For "file_read": extract line count and first line (truncated to 60 chars). Format: `"[file_read result masked -- {N} lines, starts with: {first_line}]"`
   - For "shell_exec": try to parse as JSON, extract exit_code and stdout byte length. Format: `"[shell_exec result masked -- exit_code={code}, stdout={N} bytes]"`. If not JSON: `"[shell_exec result masked -- {N} bytes of output]"`
   - For "file_write": format as `"[file_write result masked -- {N} bytes]"`
   - Default: `"[{fn_name} result masked -- {N} bytes of output]"`
   - All placeholders start with `[` and contain `masked` so is_already_masked can detect them.

3. **is_already_masked(content: &str) -> bool** -- returns true if content starts with `"["` and contains `"masked"`.

4. **mask_oldest_observations(messages: &mut Vec<ChatMessage>, count: usize) -> MaskResult** -- walks messages from oldest to newest:
   - For each message with role Tool (check via the ChatMessage API -- messages created via ToolResponse have a tool role):
     - Skip if is_already_masked (check message content string)
     - Extract the tool call's fn_name from the conversation context (the preceding assistant message's tool calls contain the fn_name matching by call_id). If fn_name can't be determined, use "unknown".
     - Call generate_placeholder with the fn_name and current content
     - Replace message content with the placeholder string
     - Increment masked counter
     - Stop when `count` observations have been masked
   - Return MaskResult { masked_count: usize, total_masked: usize }

   IMPORTANT: genai's ChatMessage uses MessageContent for content, not a plain String. The exact API for reading/writing content will need to be discovered during implementation. The key constraint is: NEVER remove messages from the Vec, only replace their content. The message role and position must remain intact to preserve the tool call/response chain.

   If ChatMessage content mutation proves difficult with genai's API, an alternative approach: store a parallel Vec<bool> or HashSet<usize> tracking which message indices are masked, and reconstruct messages with placeholder content when building the ChatRequest. Pick whichever approach compiles cleanly.

5. **generate_mask_notification(masked_count: usize, total_masked: usize, reclaimed_pct: f64) -> String** -- returns the system notification text: `"[Context compressed: {masked_count} observations masked this round, {total_masked} total, ~{reclaimed_pct:.0}% context reclaimed]"`

Add unit tests:
- `test_generate_placeholder_file_read` -- verify file_read placeholder format
- `test_generate_placeholder_shell_exec_json` -- verify shell_exec JSON parsing
- `test_generate_placeholder_shell_exec_plain` -- verify shell_exec fallback
- `test_is_already_masked` -- verify detection of masked vs unmasked content
  </action>
  <verify>
`cargo check` compiles cleanly.
`cargo test context_manager` passes all tests (previous 6 + new 4 = 10 total).
  </verify>
  <done>
Observation masking generates descriptive summary placeholders for each tool type. Masking walks oldest-first and skips already-masked observations. 10 unit tests pass in context_manager module.
  </done>
</task>

</tasks>

<verification>
- `cargo check` compiles cleanly
- `cargo test` passes all tests (existing + 10 new context_manager tests)
- ContextManager correctly evaluates all four threshold zones
- Observation masking produces readable summary placeholders
- Character fallback works when token data is unavailable
</verification>

<success_criteria>
- ContextManager struct with full token tracking and graduated threshold evaluation
- Four ContextAction variants correctly returned based on usage percentage
- Observation masking replaces tool output with descriptive placeholders
- Character-count fallback when prompt_tokens is 0
- 10 unit tests covering threshold logic, masking, and placeholders
- No new external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-management-resilience/03-02-SUMMARY.md`
</output>
