---
phase: 03-context-management-resilience
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/agent/agent_loop.rs
  - src/agent/system_prompt.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Token usage is extracted from every StreamEnd and fed to ContextManager"
    - "Observation masking triggers automatically when soft threshold is reached"
    - "Agent receives wind-down message at hard threshold and can save state before restart"
    - "Session restarts automatically with system prompt reloaded from disk plus carryover turns"
    - "Agent sees restart marker message with session number and previous turn count"
    - "Max restarts and auto_restart config options are honored"
  artifacts:
    - path: "src/agent/agent_loop.rs"
      provides: "run_agent_session with ContextManager integration, token tracking, masking, wind-down"
      contains: "context_manager"
    - path: "src/agent/agent_loop.rs"
      provides: "ShutdownReason enum and SessionResult struct"
      contains: "pub enum ShutdownReason"
    - path: "src/main.rs"
      provides: "Outer restart loop calling run_agent_session in a loop"
      contains: "session_number"
    - path: "src/agent/system_prompt.rs"
      provides: "Session-aware system prompt with optional restart marker"
      contains: "session_number"
  key_links:
    - from: "src/agent/agent_loop.rs"
      to: "src/agent/context_manager.rs"
      via: "ContextManager created in run_agent_session, evaluate() called after each turn"
      pattern: "context_manager\\.evaluate"
    - from: "src/agent/agent_loop.rs"
      to: "genai StreamEnd.captured_usage"
      via: "Token extraction from end.captured_usage in stream handler"
      pattern: "captured_usage"
    - from: "src/main.rs"
      to: "src/agent/agent_loop.rs"
      via: "Outer loop calls run_agent_session, handles ShutdownReason::ContextFull"
      pattern: "ShutdownReason::ContextFull"
    - from: "src/agent/system_prompt.rs"
      to: "SYSTEM_PROMPT.md on disk"
      via: "Re-read from disk on each session start (agent may have modified it)"
      pattern: "read_to_string.*SYSTEM_PROMPT"
---

<objective>
Wire ContextManager into the agent loop, add token tracking from StreamEnd, implement the outer restart loop with carryover, and add restart markers to the system prompt.

Purpose: This is the capstone plan that makes the agent self-sustaining across context window boundaries. After this plan, the harness can run indefinitely -- masking observations when context gets tight, warning the agent to save state, restarting with carryover turns, and reloading the system prompt (which the agent may have modified).
Output: A working end-to-end context management pipeline: token tracking -> graduated thresholds -> observation masking -> wind-down -> restart with continuity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-context-management-resilience/03-CONTEXT.md
@.planning/phases/03-context-management-resilience/03-RESEARCH.md
@src/agent/agent_loop.rs
@src/agent/system_prompt.rs
@src/main.rs

# Prior plans provide the types this plan wires together
@.planning/phases/03-context-management-resilience/03-01-SUMMARY.md
@.planning/phases/03-context-management-resilience/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor agent_loop.rs -- integrate ContextManager, token tracking, masking, and wind-down</name>
  <files>src/agent/agent_loop.rs, src/agent/system_prompt.rs</files>
  <action>
This is the main integration task. Refactor `run_agent_loop` into `run_agent_session` and wire ContextManager throughout.

**1. Add ShutdownReason enum and SessionResult struct** at the top of agent_loop.rs:
```rust
pub enum ShutdownReason {
    UserShutdown,
    ContextFull { carryover_messages: Vec<ChatMessage> },
    MaxTurnsOrError(String),
}

pub struct SessionResult {
    pub shutdown_reason: ShutdownReason,
    pub turns_completed: u64,
    pub session_number: u32,
}
```

**2. Rename `run_agent_loop` to `run_agent_session`** and change its signature:
```rust
pub async fn run_agent_session(
    config: &AppConfig,
    safety: &SafetyLayer,
    session_number: u32,
    carryover_messages: &[ChatMessage],
    shutdown: Arc<AtomicBool>,  // Shared across sessions
) -> anyhow::Result<SessionResult>
```

Key changes from the old run_agent_loop:
- Accept session_number and carryover_messages parameters
- Accept shutdown flag from caller (not created internally -- the outer loop owns it)
- Return SessionResult instead of Ok(())

**3. Create ContextManager at session start:**
```rust
let mut context_manager = ContextManager::new(
    config.context_limit,
    config.soft_threshold_pct,
    config.hard_threshold_pct,
    config.carryover_turns,
);
```
Set session_number on the context_manager if it exposes a setter, or pass it to the constructor.

**4. Enable capture_usage on ChatOptions:**
```rust
let chat_options = ChatOptions::default()
    .with_capture_content(true)
    .with_capture_tool_calls(true)
    .with_capture_usage(true);  // NEW -- enables token tracking
```

**5. Add carryover messages to chat_req after system prompt:**
If carryover_messages is non-empty, append them to the initial chat_req. These are the last N complete interaction cycles from the previous session.

**6. Inject restart marker if session_number > 1:**
If this is a restarted session (session_number > 1), append a system message to chat_req with the restart marker:
```
"[Session restarted. Session #{session_number}. Previous session context was full. Check your workspace files for progress state.]"
```

**7. Extract token usage from StreamEnd:**
In the stream event handler, after the existing `ChatStreamEvent::End(end)` handling, add:
```rust
if let Some(usage) = &end.captured_usage {
    let prompt_toks = usage.prompt_tokens.unwrap_or(0) as usize;
    let completion_toks = usage.completion_tokens.unwrap_or(0) as usize;
    context_manager.update_token_usage(prompt_toks, completion_toks);
    logger.log_event(&LogEntry::TokenUsage {
        timestamp: now_iso_timestamp(),  // use the same timestamp helper pattern
        turn,
        prompt_tokens: prompt_toks,
        completion_tokens: completion_toks,
        total_tokens: prompt_toks + completion_toks,
        context_used_pct: context_manager.usage_percentage(),
    })?;
}
```
Keep the existing total_chars tracking as well -- feed it to context_manager.add_chars() for the fallback heuristic.

**8. After each turn, evaluate context pressure and act:**
Replace the old `estimated_tokens > config.context_limit` check with:
```rust
context_manager.increment_turn();
match context_manager.evaluate() {
    ContextAction::Continue => { /* no action */ }
    ContextAction::Mask { count } => {
        // Mask oldest observations
        let mask_result = mask_oldest_observations(&mut chat_req.messages, count);
        context_manager.record_masking(mask_result.masked_count);
        // Log masking event
        logger.log_event(&LogEntry::ContextMask { ... })?;
        // Inject system notification
        let notification = generate_mask_notification(...);
        chat_req = chat_req.append_message(ChatMessage::system(notification));
        eprintln!("[context] {}", notification_summary);
    }
    ContextAction::WindDown => {
        // Inject wind-down message
        let msg = format!(
            "[Context window {:.0}% full. Please wrap up your current task and \
             write any important state to workspace files. The session will restart shortly.]",
            context_manager.usage_percentage() * 100.0
        );
        chat_req = chat_req.append_message(ChatMessage::system(msg.clone()));
        logger.log_event(&LogEntry::SystemMessage { timestamp: ..., content: msg })?;
        eprintln!("[context] Wind-down message sent");
        // Don't break yet -- let the agent have one more turn to save state
    }
    ContextAction::Restart => {
        // Extract carryover messages (last N complete interaction cycles)
        let carryover = extract_carryover(&chat_req.messages, config.carryover_turns);
        // Log restart event
        logger.log_event(&LogEntry::SessionRestart { ... })?;
        logger.log_session_end(turn, "context_full_restart")?;
        return Ok(SessionResult {
            shutdown_reason: ShutdownReason::ContextFull { carryover_messages: carryover },
            turns_completed: turn,
            session_number: context_manager.session_number(),
        });
    }
}
```

**9. Implement extract_carryover(messages: &[ChatMessage], n_turns: usize) -> Vec<ChatMessage>:**
Scan backward from the end of messages to find clean break points. A "turn boundary" is after an assistant text response (not a tool call response), before the next user/system message. Extract the last `n_turns` complete interaction cycles. Clone the messages for carryover.

IMPORTANT: Never split a tool call/response pair. If the last messages are: assistant(tool_calls) -> tool_response -> tool_response, include the full sequence.

**10. Update system_prompt.rs:**
Modify `build_system_prompt` to accept an optional `session_number: u32` parameter (or add a separate function). When session_number > 1, add a section to the harness preamble:
```
## Session Continuity
This is session #{session_number}. You have been restarted due to context window limits.
Your SYSTEM_PROMPT.md is reloaded from disk each restart -- if you modified it, your changes are active.
Check your workspace for any state files you wrote in previous sessions.
```

The system prompt MUST be re-read from disk on each session start (not cached). The agent may have modified SYSTEM_PROMPT.md during the previous session per the Ouroboros self-modification philosophy.

**11. Move Ctrl+C handler setup to NOT be inside run_agent_session:**
The shutdown Arc<AtomicBool> is now passed in from the caller. Remove the tokio::spawn for Ctrl+C handling from this function -- it will be set up once in the outer loop (main.rs).

**12. Update the `run_agent_loop` function name references.**
Keep `check_ollama_ready` as-is (called once per session).

AVOID: Do not change the streaming logic, tool dispatch logic, or logger creation. Only add the ContextManager integration points and restructure the function signature/return type.
  </action>
  <verify>
`cargo check` compiles cleanly.
`cargo test agent_loop` passes (existing health check test still works).
  </verify>
  <done>
agent_loop.rs exports run_agent_session with ContextManager integration. Token usage extracted from StreamEnd. Masking triggers at soft threshold. Wind-down injected at hard threshold. Restart returns carryover messages. System prompt reloaded from disk each session.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement outer restart loop in main.rs</name>
  <files>src/main.rs</files>
  <action>
Modify `src/main.rs` to wrap `run_agent_session` in an outer restart loop:

**1. Move Ctrl+C shutdown handler to main.rs:**
Set up the Arc<AtomicBool> shutdown flag and the Ctrl+C tokio::spawn handler ONCE, before the session loop. Pass the flag into run_agent_session.

**2. Implement the outer restart loop** in the `Commands::Run` branch:
```rust
cli::Commands::Run { .. } => {
    let safety = SafetyLayer::new(&config)?;
    // ... existing tracing ...

    // Set up shutdown signal (once, shared across sessions)
    let shutdown = Arc::new(AtomicBool::new(false));
    let shutdown_clone = shutdown.clone();
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.ok();
        shutdown_clone.store(true, Ordering::SeqCst);
        eprintln!("\nShutting down after current turn... (Ctrl+C again to force quit)");
        tokio::signal::ctrl_c().await.ok();
        eprintln!("\nForce quitting.");
        std::process::exit(1);
    });

    let mut session_number: u32 = 1;
    let mut carryover_messages: Vec<ChatMessage> = Vec::new();

    loop {
        let result = agent::agent_loop::run_agent_session(
            &config,
            &safety,
            session_number,
            &carryover_messages,
            shutdown.clone(),
        ).await?;

        match result.shutdown_reason {
            ShutdownReason::ContextFull { carryover_messages: carry } => {
                // Check max_restarts
                if let Some(max) = config.max_restarts {
                    if session_number >= max {
                        eprintln!("Max restarts ({max}) reached. Exiting.");
                        break;
                    }
                }

                // Check auto_restart
                if !config.auto_restart {
                    eprintln!("Session context full. Auto-restart disabled. Press Enter to continue or Ctrl+C to exit.");
                    let mut input = String::new();
                    std::io::stdin().read_line(&mut input)?;
                    if shutdown.load(Ordering::SeqCst) {
                        break;
                    }
                }

                // Check if user triggered shutdown during the session
                if shutdown.load(Ordering::SeqCst) {
                    break;
                }

                session_number += 1;
                carryover_messages = carry;
                eprintln!("\n--- Starting session #{session_number} ---\n");
            }
            ShutdownReason::UserShutdown => {
                eprintln!("User shutdown. {session_number} session(s) completed.");
                break;
            }
            ShutdownReason::MaxTurnsOrError(msg) => {
                eprintln!("Session ended: {msg}");
                break;
            }
        }
    }
}
```

**3. Add necessary imports** to main.rs:
- `use std::sync::atomic::{AtomicBool, Ordering};`
- `use std::sync::Arc;`
- `use genai::chat::ChatMessage;`
- `use agent::agent_loop::ShutdownReason;`

**4. Wire the `Resume` command** to print a more informative message:
```rust
cli::Commands::Resume { .. } => {
    eprintln!("Resume not yet implemented. The agent auto-restarts sessions when context fills.");
}
```

AVOID: Do not change any other part of main.rs (tracing init, config loading, CLI parsing). Keep changes minimal and focused on the outer restart loop.
  </action>
  <verify>
`cargo check` compiles cleanly with no warnings.
`cargo test` passes all tests across the full crate.
Run `cargo build` to produce a working binary.
  </verify>
  <done>
main.rs has an outer restart loop that handles ContextFull by incrementing session number and passing carryover messages to the next session. Max restarts and auto_restart config options are honored. Ctrl+C shutdown is shared across sessions. The binary compiles and the full test suite passes.
  </done>
</task>

</tasks>

<verification>
- `cargo check` compiles the full crate cleanly
- `cargo test` passes all tests (existing + new from plans 01 and 02)
- `cargo build` produces a working binary
- The agent_loop extracts token usage from StreamEnd (capture_usage enabled)
- ContextManager is called after every turn
- Observation masking triggers at soft threshold
- Wind-down message is injected at hard threshold
- Session restarts with carryover messages at context exhaustion
- System prompt is re-read from disk on each session start
- Max restarts and auto_restart are configurable and honored
</verification>

<success_criteria>
- Token usage extracted from genai StreamEnd.captured_usage (with char fallback)
- Graduated thresholds: soft -> mask, hard -> wind-down, post-wind-down -> restart
- Agent receives masking notification, wind-down message, and restart marker
- Carryover messages preserve complete interaction cycles (no split tool call pairs)
- System prompt reloaded from disk each session (supports agent self-modification)
- Outer loop in main.rs handles restart, max_restarts, auto_restart, and Ctrl+C
- All existing tests pass, binary compiles
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-management-resilience/03-03-SUMMARY.md`
</output>
