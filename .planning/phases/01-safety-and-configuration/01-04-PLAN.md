---
phase: 01-safety-and-configuration
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/exec/shell.rs
  - src/exec/mod.rs
  - src/safety/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Shell commands execute in the workspace directory and return stdout, stderr, and exit code"
    - "Commands that exceed the timeout are killed and return partial output plus a timeout indicator"
    - "The process group is killed on timeout (not just the parent shell process)"
    - "Blocked commands never reach shell execution -- they are rejected with structured JSON"
    - "Blocked commands are logged to a separate security log file"
    - "The main entry point loads config, builds guards, and is ready to execute commands"
  artifacts:
    - path: "src/exec/shell.rs"
      provides: "Async shell execution with timeout, process group kill, partial output capture"
      exports: ["execute_shell", "ExecResult"]
      min_lines: 50
    - path: "src/safety/mod.rs"
      provides: "Combined safety layer: check command filter then execute if allowed"
      exports: ["SafetyLayer"]
      min_lines: 30
    - path: "src/main.rs"
      provides: "Entry point: parse CLI, load config, initialize guards, ready for agent loop"
      contains: "tokio::main"
      min_lines: 30
  key_links:
    - from: "src/safety/mod.rs"
      to: "src/safety/command_filter.rs"
      via: "SafetyLayer delegates to CommandFilter::check before execution"
      pattern: "command_filter.*check"
    - from: "src/safety/mod.rs"
      to: "src/safety/workspace.rs"
      via: "SafetyLayer holds WorkspaceGuard for path validation"
      pattern: "WorkspaceGuard"
    - from: "src/safety/mod.rs"
      to: "src/exec/shell.rs"
      via: "SafetyLayer calls execute_shell for allowed commands"
      pattern: "execute_shell"
    - from: "src/main.rs"
      to: "src/config/mod.rs"
      via: "main loads config before building safety layer"
      pattern: "load_config"
    - from: "src/main.rs"
      to: "src/safety/mod.rs"
      via: "main constructs SafetyLayer from config"
      pattern: "SafetyLayer"
---

<objective>
Implement shell execution with timeout/process-group management, wire all safety modules together into a SafetyLayer, and connect everything in the main entry point.

Purpose: This is the integration plan that makes all the independent modules work together. After this plan, `ouro run` loads config, builds the safety layer (command filter + workspace guard), and can execute shell commands with full guardrails (blocklist check -> workspace validation -> timeout-enforced execution -> security logging).
Output: A working `ouro run` command that initializes the complete safety system, ready for the agent loop in Phase 2.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-safety-and-configuration/01-CONTEXT.md
@.planning/phases/01-safety-and-configuration/01-RESEARCH.md
@.planning/phases/01-safety-and-configuration/01-01-SUMMARY.md
@.planning/phases/01-safety-and-configuration/01-02-SUMMARY.md
@.planning/phases/01-safety-and-configuration/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shell execution with timeout and partial output capture</name>
  <files>
    src/exec/shell.rs
    src/exec/mod.rs
  </files>
  <action>
    Implement async shell execution in src/exec/shell.rs following RESEARCH.md patterns:

    ExecResult struct (Serialize derive):
    - stdout: String
    - stderr: String
    - exit_code: Option<i32>
    - timed_out: bool

    pub async fn execute_shell(command: &str, working_dir: &Path, timeout_secs: u64) -> Result<ExecResult>:
    1. Spawn shell: Command::new("sh").arg("-c").arg(command)
       - .current_dir(working_dir)
       - .process_group(0) for clean kill (via std::os::unix::process::CommandExt)
       - .stdout(Stdio::piped()) and .stderr(Stdio::piped())
    2. Take stdout and stderr handles from child (child.stdout.take(), child.stderr.take())
    3. Spawn tokio tasks to read stdout and stderr into String buffers concurrently
    4. Use tokio::time::timeout wrapping a future that:
       - Waits for the child to exit
       - Joins the stdout/stderr reader tasks
    5. On success: return ExecResult with full output, exit code, timed_out: false
    6. On timeout:
       - Kill the process group using nix::sys::signal::killpg with SIGKILL
         (use nix::unistd::Pid::from_raw(child.id().unwrap() as i32) and nix::sys::signal::Signal::SIGKILL)
       - Wait for child to be reaped: child.wait().await (prevents zombies)
       - Collect whatever partial output was buffered before the kill
       - Return ExecResult with partial stdout/stderr, exit_code: None, timed_out: true

    IMPORTANT: Do NOT use kill_on_drop -- it causes zombie processes (see RESEARCH.md Pitfall 1).
    IMPORTANT: Use nix crate for killpg (safe wrapper, no unsafe blocks). See RESEARCH.md Open Question 3.
    IMPORTANT: The partial output capture on timeout is critical -- read stdout/stderr in parallel
    tasks so data is buffered even if the process hangs. On timeout, abort the read tasks and
    return whatever was collected.

    src/exec/mod.rs: re-export execute_shell and ExecResult.
  </action>
  <verify>
    Write a test in tests/shell_exec_tests.rs:
    - Test normal execution: `execute_shell("echo hello", workspace, 5)` returns stdout "hello\n", exit_code Some(0), timed_out false
    - Test timeout: `execute_shell("sleep 60", workspace, 1)` returns timed_out true within ~2 seconds
    - Test stderr: `execute_shell("echo err >&2", workspace, 5)` returns stderr "err\n"
    - Test exit code: `execute_shell("exit 42", workspace, 5)` returns exit_code Some(42)
    - Test working directory: `execute_shell("pwd", workspace, 5)` returns the workspace path
    Run with `cargo test shell_exec`.
  </verify>
  <done>
    Shell execution works with timeout enforcement. Timed-out processes are killed via process group. Partial output captured on timeout. No zombie processes after timeout. All test cases pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SafetyLayer and main entry point</name>
  <files>
    src/safety/mod.rs
    src/main.rs
  </files>
  <action>
    Implement SafetyLayer in src/safety/mod.rs:

    pub struct SafetyLayer {
        command_filter: CommandFilter,
        workspace_guard: WorkspaceGuard,
        timeout_secs: u64,
        security_log_path: PathBuf,
    }

    impl SafetyLayer:
    - pub fn new(config: &AppConfig) -> Result<Self>:
      Build CommandFilter from config.blocked_patterns (the Vec of (String, String) tuples).
      Build WorkspaceGuard from config.workspace.
      Store timeout_secs and security_log_path from config.

    - pub async fn execute(&self, command: &str) -> Result<ExecResult>:
      1. Check command against filter: self.command_filter.check(command)
      2. If blocked: log to security log file (append a JSON line to security_log_path),
         return an ExecResult with the blocked JSON in stderr, exit_code None, timed_out false
         (OR return an Err -- use ExecResult for consistency since the agent needs structured output)
         Decision: return Ok(ExecResult) where stdout is empty and stderr contains the BlockedCommand JSON.
         Set exit_code to Some(126) (standard "cannot execute" code).
      3. If allowed: call execute_shell(command, self.workspace_guard.canonical_root(), self.timeout_secs)
      4. Return the ExecResult

    - fn log_blocked_command(&self, blocked: &BlockedCommand):
      Append a JSON line to the security log file. Use std::fs::OpenOptions append mode.
      Include timestamp (use chrono or just format with std::time::SystemTime).
      Format: {"timestamp": "...", "blocked": true, "reason": "...", "command": "..."}
      Do NOT use chrono -- use std::time::SystemTime for the timestamp to avoid adding a dep.
      If the log file cannot be written (permissions, etc.), log a warning via tracing but do NOT fail the command check.

    - pub fn workspace_root(&self) -> &Path: delegate to workspace_guard.canonical_root()

    Wire main.rs:
    1. Parse CLI with Cli::parse()
    2. Initialize tracing subscriber (tracing_subscriber::fmt::init() with env filter)
    3. Match on command:
       - Commands::Run { .. }: load_config, build SafetyLayer, log the loaded config summary
         (model, workspace, timeout, number of blocklist patterns), then print a message like
         "Ouroboros initialized. Safety layer active. Waiting for agent loop (Phase 2)."
         For now, just exit cleanly after initialization since the agent loop is Phase 2.
       - Commands::Resume { .. }: print "Resume not yet implemented" and exit
    4. Handle errors with anyhow: main returns Result<()>

    IMPORTANT: The safety log is append-only. Each blocked command is one JSON line.
    IMPORTANT: SafetyLayer.execute() is the single entry point for all command execution.
    No code should call execute_shell directly -- always go through SafetyLayer.
    IMPORTANT: Do NOT add chrono as a dependency. Use SystemTime for timestamps.
  </action>
  <verify>
    Write integration tests in tests/integration_tests.rs:
    - Test SafetyLayer blocks "sudo ls" and returns ExecResult with blocked JSON in stderr
    - Test SafetyLayer executes "echo hello" and returns stdout
    - Test SafetyLayer handles timeout for "sleep 60" with 1-second timeout
    - Test security log file is created and contains blocked command entry
    Run with `cargo test integration`.
    Also run: `cargo run -- run --workspace /tmp/ouro-test` and verify it prints initialization message and exits cleanly.
  </verify>
  <done>
    SafetyLayer correctly chains command filter -> shell execution with timeout. Blocked commands logged to security file. main.rs loads config, builds SafetyLayer, and initializes cleanly. `ouro run` works end-to-end (init only, no agent loop yet). All integration tests pass.
  </done>
</task>

</tasks>

<verification>
Phase-level checks (run after this plan completes):
- `cargo build` compiles cleanly
- `cargo test` passes ALL tests (unit + integration)
- `cargo run -- run --workspace /tmp/ouro-test --model test-model --timeout 5` initializes and exits cleanly
- `cargo run -- run --help` shows all CLI options
- Blocked command test: SafetyLayer.execute("sudo ls") returns blocked JSON, writes to security log
- Timeout test: SafetyLayer.execute("sleep 60") with 1s timeout returns within ~2 seconds
- Normal execution: SafetyLayer.execute("echo hello") returns "hello\n"
- No zombie processes after running timeout tests (check with `ps aux | grep defunct`)
</verification>

<success_criteria>
1. Shell execution works with stdout, stderr, exit code capture
2. Timeout kills entire process group (not just parent), returns partial output
3. No zombie processes after timeout
4. SafetyLayer checks blocklist before executing any command
5. Blocked commands logged to security.log as append-only JSON lines
6. main.rs loads config, builds safety layer, and runs to completion
7. All tests pass: unit (shell exec), integration (safety layer end-to-end)
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-and-configuration/01-04-SUMMARY.md`
</output>
