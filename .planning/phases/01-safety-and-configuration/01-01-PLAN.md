---
phase: 01-safety-and-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/cli.rs
  - src/error.rs
  - src/config/mod.rs
  - src/config/schema.rs
  - src/config/merge.rs
autonomous: true

must_haves:
  truths:
    - "Running `cargo build` compiles the project with all dependencies"
    - "Config loads from global (~/.config/ouro/ouro.toml), workspace (workspace/ouro.toml), and CLI args with correct precedence"
    - "`ouro run --model X --workspace Y` parses arguments and feeds them into config"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project manifest with all Phase 1 dependencies"
      contains: "clap.*toml.*serde.*tokio.*regex"
    - path: "src/cli.rs"
      provides: "CLI argument parsing with subcommands"
      contains: "Commands"
      exports: ["Cli", "Commands"]
    - path: "src/error.rs"
      provides: "Typed error definitions for all Phase 1 modules"
      exports: ["ConfigError", "GuardrailError", "ExecError"]
    - path: "src/config/mod.rs"
      provides: "Config loading public API"
      exports: ["load_config", "AppConfig"]
    - path: "src/config/schema.rs"
      provides: "Config struct definitions"
      exports: ["AppConfig", "PartialConfig", "ConfigFile"]
    - path: "src/config/merge.rs"
      provides: "Config layering logic"
      contains: "with_fallback"
  key_links:
    - from: "src/cli.rs"
      to: "src/config/mod.rs"
      via: "CLI args converted to PartialConfig for merge"
      pattern: "to_partial"
    - from: "src/config/mod.rs"
      to: "src/config/merge.rs"
      via: "with_fallback chaining"
      pattern: "with_fallback"
    - from: "src/config/mod.rs"
      to: "src/config/schema.rs"
      via: "ConfigFile deserialized from TOML, finalized to AppConfig"
      pattern: "finalize"
---

<objective>
Scaffold the Ouroboros Rust project and implement the layered configuration system with CLI parsing.

Purpose: Every subsequent plan depends on the project existing and config being loadable. This is the foundation that all safety modules, shell execution, and wiring build on.
Output: A compiling Rust project with working config loading (global -> workspace -> CLI precedence) and CLI argument parsing via clap subcommands.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-safety-and-configuration/01-CONTEXT.md
@.planning/phases/01-safety-and-configuration/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Rust project with all dependencies and module stubs</name>
  <files>
    Cargo.toml
    src/main.rs
    src/error.rs
    src/config/mod.rs
    src/config/schema.rs
    src/config/merge.rs
    src/cli.rs
    src/safety/mod.rs
    src/safety/command_filter.rs
    src/safety/workspace.rs
    src/safety/defaults.rs
    src/exec/mod.rs
    src/exec/shell.rs
  </files>
  <action>
    Initialize a Rust project (if not already initialized) with `cargo init --name ouro`.

    Create Cargo.toml with these dependencies (exact versions from RESEARCH.md):
    - clap = { version = "4.5", features = ["derive"] }
    - toml = "0.9"
    - serde = { version = "1.0", features = ["derive"] }
    - serde_json = "1.0"
    - tokio = { version = "1", features = ["process", "time", "fs", "rt-multi-thread", "macros"] }
    - regex = "1.12"
    - directories = "5"
    - anyhow = "1"
    - thiserror = "1"
    - tracing = "0.1"
    - tracing-subscriber = { version = "0.3", features = ["env-filter"] }
    - nix = { version = "0.29", features = ["signal", "process"] }

    Create error.rs with typed error enums using thiserror:
    - ConfigError: IoError, ParseError(path, message), MergeError
    - GuardrailError: CommandBlocked { command, reason }, WriteOutsideWorkspace { path, workspace }
    - ExecError: SpawnFailed, TimedOut { timeout_secs, partial_output }, ProcessFailed

    Create module stubs (just `pub mod` declarations and minimal struct/function signatures) for:
    - src/safety/mod.rs (pub mod command_filter, workspace, defaults)
    - src/safety/command_filter.rs (pub struct CommandFilter, pub fn check placeholder)
    - src/safety/workspace.rs (pub struct WorkspaceGuard placeholder)
    - src/safety/defaults.rs (pub fn default_blocklist placeholder returning empty vec)
    - src/exec/mod.rs (pub mod shell)
    - src/exec/shell.rs (pub struct ExecResult placeholder)
    - src/config/mod.rs (pub mod schema, merge)

    Create src/main.rs that declares all modules and has a minimal tokio main function.
    Create src/cli.rs with the full clap derive implementation (this is finalized, not a stub):
    - Cli struct with subcommand
    - Commands enum: Run { model, workspace, timeout, config }, Resume { workspace }
    - See RESEARCH.md for exact structure

    The project MUST compile with `cargo build` (stubs can use todo!() for function bodies).
  </action>
  <verify>
    `cargo build` succeeds with no errors. `cargo run -- --help` shows the CLI help text with Run and Resume subcommands.
  </verify>
  <done>
    Project compiles. CLI help displays correctly. All module files exist with proper module declarations. Error types are defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config loading with layered merge and TOML parsing</name>
  <files>
    src/config/schema.rs
    src/config/merge.rs
    src/config/mod.rs
    src/cli.rs
  </files>
  <action>
    Implement the full config system following RESEARCH.md patterns:

    src/config/schema.rs:
    - ConfigFile struct (deserializable from TOML): has optional `general` (GeneralConfig) and `safety` (SafetyConfig) sections
    - GeneralConfig: model (Option String), workspace (Option String)
    - SafetyConfig: shell_timeout_secs (Option u64), context_limit (Option usize), blocked_patterns (Option Vec BlocklistEntry), security_log (Option String)
    - BlocklistEntry: pattern (String), reason (String)
    - AppConfig: the fully-resolved config with all fields non-optional (model, workspace as PathBuf, shell_timeout_secs, context_limit, blocked_patterns as Vec of (String, String) tuples, security_log_path as PathBuf)
    - PartialConfig: mirrors AppConfig but all fields Option, used for merge

    src/config/merge.rs:
    - PartialConfig::with_fallback(self, fallback) -> PartialConfig: for each field, self.field.or(fallback.field)
    - For blocked_patterns: REPLACE semantics (if self has Some, use it entirely; do NOT merge arrays)
    - PartialConfig::finalize(self) -> AppConfig: unwrap all Options with sensible defaults:
      - model: "llama3.2"
      - workspace: PathBuf::from("./workspace")
      - shell_timeout_secs: 30
      - context_limit: 32768
      - blocked_patterns: call default_blocklist() from safety::defaults
      - security_log_path: workspace.join("security.log")
    - ConfigFile::to_partial(self) -> PartialConfig: convert parsed TOML into the merge-friendly format

    src/config/mod.rs:
    - pub fn load_config(cli: &Cli) -> Result<AppConfig>
    - Load global config: use directories::ProjectDirs::from("", "", "ouro") to find config dir, read ouro.toml
    - Load workspace config: determine workspace path (CLI > global config > default), read workspace/ouro.toml
    - Convert CLI args to PartialConfig
    - Merge: CLI.with_fallback(workspace).with_fallback(global).finalize()
    - Log which config files were found/loaded using tracing::info/debug
    - Return Ok(AppConfig)
    - Handle file-not-found gracefully (return empty PartialConfig, not error)

    src/cli.rs updates:
    - Add a method to convert Run args to PartialConfig (to_partial_config)

    IMPORTANT: Do NOT restrict the version constraints in Cargo.toml beyond what's already specified. Use the versions from Task 1.
    IMPORTANT: Config loading must NOT panic on missing files. Missing files = defaults apply.
    IMPORTANT: Log which config files were loaded vs not found (tracing::info for loaded, tracing::debug for not found).
  </action>
  <verify>
    `cargo build` succeeds. Write a simple unit test in config/merge.rs:
    - Test that CLI values override workspace values
    - Test that workspace values override global values
    - Test that defaults apply when no config provided
    - Test that blocked_patterns uses replace semantics (not merge)
    Run with `cargo test`.
  </verify>
  <done>
    Config system compiles and passes merge tests. load_config correctly chains global -> workspace -> CLI with proper precedence. Missing files handled gracefully. Defaults applied for all unset fields.
  </done>
</task>

</tasks>

<verification>
- `cargo build` compiles cleanly
- `cargo test` passes all config merge tests
- `cargo run -- run --help` shows Run subcommand options (--model, --workspace, --timeout, --config)
- `cargo run -- --help` shows both Run and Resume subcommands
- All module files exist at expected paths
</verification>

<success_criteria>
1. Project compiles with all Phase 1 dependencies
2. CLI parsing works for `ouro run` and `ouro resume` subcommands
3. Config merge correctly implements CLI > workspace > global > defaults precedence
4. blocked_patterns uses replace semantics (workspace blocklist fully replaces global)
5. Missing config files are handled gracefully (no panic, defaults apply)
6. Error types defined for all three modules (config, guardrail, exec)
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-and-configuration/01-01-SUMMARY.md`
</output>
