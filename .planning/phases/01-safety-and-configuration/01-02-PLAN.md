---
phase: 01-safety-and-configuration
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/safety/command_filter.rs
  - src/safety/defaults.rs
  - tests/command_filter_tests.rs
autonomous: true

must_haves:
  truths:
    - "Commands containing sudo/su/doas are blocked with a reason explaining why"
    - "Commands with destructive root patterns (rm -rf /) are blocked"
    - "Commands with system directory writes (> /etc/) are blocked"
    - "Safe commands (ls, cat, pip install, cargo build) are allowed through"
    - "The blocklist is configurable -- custom patterns can be provided instead of defaults"
    - "Blocked commands return structured JSON with {blocked, reason, command}"
  artifacts:
    - path: "src/safety/command_filter.rs"
      provides: "CommandFilter with RegexSet-based pattern matching"
      exports: ["CommandFilter", "BlockedCommand"]
      min_lines: 40
    - path: "src/safety/defaults.rs"
      provides: "Default blocklist entries covering privilege escalation, destructive ops, system writes"
      exports: ["default_blocklist"]
      min_lines: 30
    - path: "tests/command_filter_tests.rs"
      provides: "Tests for blocklist matching including edge cases"
      min_lines: 60
  key_links:
    - from: "src/safety/command_filter.rs"
      to: "regex::RegexSet"
      via: "Patterns compiled once into RegexSet for single-pass matching"
      pattern: "RegexSet::new"
    - from: "src/safety/command_filter.rs"
      to: "serde_json"
      via: "BlockedCommand serializes to JSON for agent consumption"
      pattern: "serde::Serialize"
---

<objective>
Implement the command blocklist filter using TDD, ensuring dangerous shell patterns are caught while safe commands pass through.

Purpose: The command filter is the first line of defense against dangerous shell commands. It must be correct -- false negatives allow dangerous commands, false positives break legitimate agent work.
Output: Working, tested CommandFilter that blocks dangerous patterns and returns structured JSON errors.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-safety-and-configuration/01-CONTEXT.md
@.planning/phases/01-safety-and-configuration/01-RESEARCH.md
@.planning/phases/01-safety-and-configuration/01-01-SUMMARY.md
</context>

<feature>
  <name>Command Blocklist Filter</name>
  <files>src/safety/command_filter.rs, src/safety/defaults.rs, tests/command_filter_tests.rs</files>
  <behavior>
    CommandFilter is constructed from a list of (pattern, reason) tuples.
    Patterns are compiled into a RegexSet once at construction time.
    Calling check(command) returns None if allowed, Some(BlockedCommand) if blocked.
    BlockedCommand is serializable to JSON: { "blocked": true, "reason": "...", "command": "..." }

    Test cases (input -> expected):

    BLOCKED (must return Some with correct reason):
    - "sudo apt install foo" -> blocked (privilege escalation)
    - "su root" -> blocked (privilege escalation)
    - "doas rm foo" -> blocked (privilege escalation)
    - "rm -rf /" -> blocked (destructive root deletion)
    - "rm -rf /*" -> blocked (destructive root deletion)
    - "rm -r -f /" -> blocked (destructive root deletion)
    - "> /etc/passwd" -> blocked (system directory write)
    - "> /usr/local/bin/foo" -> blocked (system directory write)
    - "mkfs.ext4 /dev/sda1" -> blocked (disk formatting)
    - "dd if=/dev/zero of=/dev/sda" -> blocked (device write)
    - "shutdown -h now" -> blocked (system shutdown)
    - "reboot" -> blocked (system reboot)
    - "chmod 777 /etc" -> blocked (root permission change)

    ALLOWED (must return None):
    - "ls -la" -> allowed
    - "cat /etc/hosts" -> allowed (reads are fine)
    - "pip install requests" -> allowed (package install OK)
    - "cargo build" -> allowed
    - "npm install express" -> allowed
    - "curl https://example.com" -> allowed
    - "python3 script.py" -> allowed
    - "rm -rf ./temp" -> allowed (not root)
    - "rm my_file.txt" -> allowed
    - "echo hello > output.txt" -> allowed (relative path write)

    EDGE CASES:
    - "SUDO apt install foo" -> blocked (case insensitive sudo)
    - Empty string "" -> allowed
    - Very long command (1000+ chars) -> does not hang or crash
    - Custom blocklist: CommandFilter::new with only one custom pattern works correctly
  </behavior>
  <implementation>
    1. Implement CommandFilter::new(patterns: &[(String, String)]) -> Result<Self, regex::Error>
       - Compile patterns into RegexSet
       - Store reasons in parallel Vec

    2. Implement CommandFilter::check(&self, command: &str) -> Option<BlockedCommand>
       - Use RegexSet::matches(command) for single-pass matching
       - Return first matching reason (or None)

    3. Implement BlockedCommand struct with Serialize derive
       - blocked: bool (always true when returned)
       - reason: String
       - command: String
       - to_json(&self) -> String method

    4. Implement default_blocklist() in defaults.rs returning Vec<(String, String)>
       - See RESEARCH.md "Default Blocklist Recommendation" for exact patterns
       - Cover: privilege escalation (sudo, su, doas), destructive root ops (rm -rf /),
         system dir writes (> /etc, /usr, /boot, /sys, /proc), disk ops (mkfs, dd),
         fork bombs, system control (shutdown, reboot, halt, poweroff),
         root permission changes (chmod, chown at /)

    5. Implement CommandFilter::from_defaults() convenience constructor
  </implementation>
</feature>

<verification>
- `cargo test command_filter` passes all test cases
- Blocked commands return valid JSON that deserializes correctly
- Default blocklist covers all categories: privilege escalation, destructive ops, system writes, disk ops, system control
- Safe commands (package install, file reads, builds, network) pass through
</verification>

<success_criteria>
1. All BLOCKED test cases return Some(BlockedCommand) with correct reason category
2. All ALLOWED test cases return None
3. Edge cases handled (case insensitivity, empty string, long commands)
4. Custom blocklist constructor works independently of defaults
5. JSON serialization of BlockedCommand produces valid JSON
6. RegexSet compiled once (not per-check)
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-and-configuration/01-02-SUMMARY.md`
</output>
