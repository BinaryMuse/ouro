---
phase: 01-safety-and-configuration
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/safety/workspace.rs
  - tests/workspace_guard_tests.rs
autonomous: true

must_haves:
  truths:
    - "Write operations to paths inside the workspace are allowed"
    - "Write operations to paths outside the workspace are rejected"
    - "Path traversal via .. is detected and blocked for writes"
    - "Writes through symlinks that resolve outside the workspace are blocked"
    - "Read operations are unrestricted (no checking needed)"
    - "Non-existent file paths are validated by canonicalizing the parent directory"
    - "Workspace directory is created if it does not exist"
  artifacts:
    - path: "src/safety/workspace.rs"
      provides: "WorkspaceGuard with canonical path comparison"
      exports: ["WorkspaceGuard"]
      min_lines: 40
    - path: "tests/workspace_guard_tests.rs"
      provides: "Tests for path validation including traversal and symlink edge cases"
      min_lines: 50
  key_links:
    - from: "src/safety/workspace.rs"
      to: "std::fs::canonicalize"
      via: "All paths resolved to canonical form before comparison"
      pattern: "canonicalize"
    - from: "src/safety/workspace.rs"
      to: "std::fs::create_dir_all"
      via: "Workspace directory created on WorkspaceGuard::new if missing"
      pattern: "create_dir_all"
---

<objective>
Implement the workspace boundary guard using TDD, ensuring write operations are restricted to the workspace directory while reads remain unrestricted.

Purpose: The workspace guard is the primary security boundary. The command blocklist catches known-bad patterns but is bypassable. The workspace guard enforces the actual boundary by checking resolved (canonical) file paths against the workspace root before every write.
Output: Working, tested WorkspaceGuard that correctly validates write paths including edge cases (traversal, symlinks, non-existent paths).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-safety-and-configuration/01-CONTEXT.md
@.planning/phases/01-safety-and-configuration/01-RESEARCH.md
@.planning/phases/01-safety-and-configuration/01-01-SUMMARY.md
</context>

<feature>
  <name>Workspace Boundary Guard</name>
  <files>src/safety/workspace.rs, tests/workspace_guard_tests.rs</files>
  <behavior>
    WorkspaceGuard is constructed with a workspace path, resolving it to canonical form.
    If the workspace directory does not exist, it is created.
    is_write_allowed(path) returns Ok(true) if the resolved path is inside the workspace, Ok(false) otherwise.
    canonical_root() returns the canonical workspace path.

    Test cases (all tests use a temp directory as workspace):

    ALLOWED writes (must return Ok(true)):
    - File directly in workspace: "workspace/file.txt"
    - File in subdirectory: "workspace/sub/dir/file.txt"
    - New file (does not exist yet, parent exists): "workspace/new_file.txt"
    - New file in new subdirectory (parent created first): "workspace/new_sub/file.txt"

    BLOCKED writes (must return Ok(false)):
    - File outside workspace: "/tmp/outside.txt"
    - Path traversal: "workspace/../../../etc/passwd"
    - Absolute path outside: "/etc/hosts"
    - Home directory: "~/.bashrc" (if outside workspace)

    SYMLINK CASES:
    - Symlink inside workspace pointing outside: create symlink workspace/link -> /tmp/target
      Writing to workspace/link should return Ok(false) because canonical path resolves outside
    - Symlink inside workspace pointing inside: create symlink workspace/link -> workspace/real
      Writing to workspace/link should return Ok(true) because canonical path is inside

    EDGE CASES:
    - Workspace itself: writing to workspace root directory path -> Ok(true)
    - Non-existent parent directory: "workspace/no_such_parent/file.txt" -> Ok(false)
      (parent does not exist and cannot be canonicalized)
    - WorkspaceGuard::new with non-existent workspace path -> creates the directory

    NOT TESTED (reads are unrestricted per user decision):
    - No is_read_allowed method exists. Reads are not checked.
  </behavior>
  <implementation>
    1. Implement WorkspaceGuard::new(workspace_path: &Path) -> Result<Self>
       - Call create_dir_all to ensure workspace exists
       - Call canonicalize to get absolute, symlink-resolved root
       - Store canonical_root

    2. Implement WorkspaceGuard::is_write_allowed(&self, target: &Path) -> Result<bool>
       - If target exists: canonicalize it fully, check starts_with(canonical_root)
       - If target does not exist but parent exists: canonicalize parent, append filename, check starts_with
       - If target does not exist and parent does not exist: return Ok(false)
       - This handles new files, path traversal, and symlinks correctly

    3. Implement WorkspaceGuard::canonical_root(&self) -> &Path
       - Simple accessor

    Note: Use std::io::Error for the Result type (not anyhow) since this is a library module.
    The workspace guard is a pure path validator -- it does NOT perform any file I/O beyond
    canonicalize and create_dir_all in the constructor.
  </implementation>
</feature>

<verification>
- `cargo test workspace_guard` passes all test cases
- Path traversal via .. is correctly detected
- Symlinks resolving outside workspace are blocked for writes
- Symlinks resolving inside workspace are allowed
- Non-existent file paths handled correctly
- Workspace directory created if it does not exist
</verification>

<success_criteria>
1. All ALLOWED test cases return Ok(true)
2. All BLOCKED test cases return Ok(false)
3. Symlink edge cases handled correctly (resolved path checked, not symlink path)
4. Non-existent paths validated via parent canonicalization
5. WorkspaceGuard::new creates missing workspace directory
6. No reads are checked or restricted
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-and-configuration/01-03-SUMMARY.md`
</output>
