---
phase: 04-tui-dashboard
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/tui/mod.rs
  - src/tui/input.rs
  - src/tui/runner.rs
  - src/main.rs
  - src/cli.rs
autonomous: true

must_haves:
  truths:
    - "The TUI main loop multiplexes agent events, keyboard input, and render ticks using tokio::select! without blocking"
    - "Keyboard input maps to tab switching (Tab/Shift-Tab), scrolling (arrows), pause/resume (p), expand/collapse (e), quit with confirmation (q then y)"
    - "The agent loop runs as a spawned tokio task, sending events through an mpsc channel to the TUI"
    - "The TUI renders at a steady tick rate (~15-30fps) and applies agent events as they arrive"
    - "User can launch in TUI mode (default) or headless mode (--headless flag)"
    - "Terminal is properly initialized on start and restored on exit/panic"
  artifacts:
    - path: "src/tui/input.rs"
      provides: "Keyboard event handler mapping key events to state mutations and control signals"
      exports: ["handle_key_event"]
    - path: "src/tui/runner.rs"
      provides: "TUI main loop with tokio::select!, terminal init/restore, render tick"
      exports: ["run_tui"]
    - path: "src/main.rs"
      provides: "Launch path for TUI mode (default) and headless mode (--headless)"
      contains: "run_tui"
    - path: "src/cli.rs"
      provides: "CLI with --headless flag"
      contains: "headless"
  key_links:
    - from: "src/tui/runner.rs"
      to: "src/agent/agent_loop.rs"
      via: "Spawns agent loop as tokio task, passes event_tx and pause_flag"
      pattern: "tokio::spawn.*run_agent_session"
    - from: "src/tui/runner.rs"
      to: "src/tui/ui.rs"
      via: "Calls render_ui on each tick"
      pattern: "render_ui.*app_state"
    - from: "src/tui/runner.rs"
      to: "src/tui/input.rs"
      via: "Calls handle_key_event on keyboard events"
      pattern: "handle_key_event"
    - from: "src/main.rs"
      to: "src/tui/runner.rs"
      via: "Calls run_tui for TUI mode, run_agent_session directly for headless"
      pattern: "run_tui"
---

<objective>
Wire the TUI main loop, keyboard input handling, and main.rs launch paths to create the complete working TUI application.

Purpose: This is the integration plan that connects everything: the agent loop (producer) to the TUI (consumer) via channels, keyboard input to state mutations, and the render loop that draws frames. After this plan, `cargo run -- run` launches the full TUI dashboard.
Output: Working TUI application with keyboard controls, real-time agent event display, and terminal lifecycle management.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-dashboard/04-RESEARCH.md
@.planning/phases/04-tui-dashboard/04-CONTEXT.md
@.planning/phases/04-tui-dashboard/04-01-SUMMARY.md
@.planning/phases/04-tui-dashboard/04-02-SUMMARY.md
@.planning/phases/04-tui-dashboard/04-03-SUMMARY.md
@src/main.rs
@src/cli.rs
@src/tui/mod.rs
@src/tui/event.rs
@src/tui/app_state.rs
@src/tui/ui.rs
@src/tui/runner.rs
@src/agent/agent_loop.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input handler and TUI runner</name>
  <files>src/tui/input.rs, src/tui/runner.rs, src/tui/mod.rs</files>
  <action>
**src/tui/input.rs** -- Keyboard event handler:

Create `handle_key_event(key: KeyEvent, state: &mut AppState, control_tx: &tokio::sync::mpsc::UnboundedSender<ControlSignal>, pause_flag: &Arc<AtomicBool>) -> bool` that returns true if the app should exit.

Use `ratatui::crossterm::event::{KeyCode, KeyEvent, KeyEventKind}`. Filter `KeyEventKind::Press` only (pitfall #7 from research -- duplicate events on Windows).

Key mappings (per CONTEXT.md decisions):
- `Tab`: state.active_tab = (state.active_tab + 1) % 2
- `Shift+Tab` (BackTab): state.active_tab = (state.active_tab + 2 - 1) % 2
- `Up arrow`: state.scroll_up()
- `Down arrow`: state.scroll_down()
- `p`: Toggle pause. If agent_state == Paused: pause_flag.store(false), send ControlSignal::Resume. Else: pause_flag.store(true), send ControlSignal::Pause.
- `e`: Toggle expand on the currently "selected" log entry at scroll offset. Call state.toggle_expand at scroll_offset position. (For v1, expand the entry at the current scroll position.)
- `g` or `End`: state.jump_to_bottom()
- `q`: If state.quit_pending: return true (confirmed quit). Else: set state.quit_pending = true.
- `y` (when quit_pending): return true.
- `n` or `Escape` (when quit_pending): state.quit_pending = false.
- Any other key when quit_pending: state.quit_pending = false (cancel quit on any non-confirming key).
- `t`: Toggle sub_agent_panel_visible.

**src/tui/runner.rs** -- TUI main loop:

Create `pub async fn run_tui(config: &AppConfig, safety: &SafetyLayer, shutdown: Arc<AtomicBool>) -> anyhow::Result<()>`:

1. Initialize terminal: `let mut terminal = ratatui::init();` (this sets up crossterm raw mode and alternate screen, plus panic hook for cleanup per research).

2. Create channels:
   ```rust
   let (event_tx, mut event_rx) = tokio::sync::mpsc::unbounded_channel::<AgentEvent>();
   let (control_tx, _control_rx) = tokio::sync::mpsc::unbounded_channel::<ControlSignal>();
   let pause_flag = Arc::new(AtomicBool::new(false));
   ```

3. Create AppState: `let mut app_state = AppState::new();`

4. Create crossterm EventStream for async keyboard input:
   ```rust
   use ratatui::crossterm::event::EventStream;
   use futures::StreamExt;
   let mut key_stream = EventStream::new();
   ```
   Note: This requires the "event-stream" feature on crossterm. Since we use ratatui's re-export, check if ratatui exposes EventStream. If not, add crossterm as a direct dependency with the "event-stream" feature ONLY (match the version ratatui 0.30 uses internally to avoid conflicts).

5. Spawn the agent loop as a tokio task (outer restart loop):
   ```rust
   let config_clone = config.clone();
   let shutdown_clone = shutdown.clone();
   let pause_clone = pause_flag.clone();
   let event_tx_clone = event_tx.clone();

   tokio::spawn(async move {
       let safety = SafetyLayer::new(&config_clone).expect("safety layer");
       let mut session_number: u32 = 1;
       let mut carryover_messages: Vec<ChatMessage> = Vec::new();

       loop {
           let result = run_agent_session(
               &config_clone,
               &safety,
               session_number,
               &carryover_messages,
               shutdown_clone.clone(),
               Some(event_tx_clone.clone()),
               Some(pause_clone.clone()),
           ).await;

           match result {
               Ok(session_result) => match session_result.shutdown_reason {
                   ShutdownReason::ContextFull { carryover_messages: carry } => {
                       // Check max_restarts
                       if let Some(max) = config_clone.max_restarts {
                           if session_number >= max { break; }
                       }
                       if shutdown_clone.load(Ordering::SeqCst) { break; }
                       session_number += 1;
                       carryover_messages = carry;
                   }
                   ShutdownReason::UserShutdown | ShutdownReason::MaxTurnsOrError(_) => break,
               },
               Err(_) => break,
           }
       }
   });
   ```

6. Main render/event loop using tokio::select!:
   ```rust
   let tick_rate = Duration::from_millis(50); // ~20fps
   let mut tick_interval = tokio::time::interval(tick_rate);

   loop {
       tokio::select! {
           // Agent events
           Some(event) = event_rx.recv() => {
               app_state.apply_event(event);
               // Auto-scroll if enabled
               if app_state.auto_scroll {
                   app_state.jump_to_bottom();
               }
           }
           // Keyboard events
           Some(Ok(crossterm_event)) = key_stream.next() => {
               if let ratatui::crossterm::event::Event::Key(key) = crossterm_event {
                   let should_quit = handle_key_event(key, &mut app_state, &control_tx, &pause_flag);
                   if should_quit {
                       shutdown.store(true, Ordering::SeqCst);
                       break;
                   }
               }
               // Handle terminal resize events
               if let ratatui::crossterm::event::Event::Resize(_, _) = crossterm_event {
                   // Ratatui handles resize automatically on next draw
               }
           }
           // Render tick
           _ = tick_interval.tick() => {
               terminal.draw(|frame| {
                   render_ui(&app_state, frame);
               })?;
           }
       }
   }
   ```

7. Cleanup: `ratatui::restore();` (restores terminal state).

Return Ok(()).

**Update src/tui/mod.rs** to add:
```rust
pub mod input;
pub mod runner;
```
  </action>
  <verify>`cargo check` succeeds. All module imports resolve.</verify>
  <done>TUI runner multiplexes three event sources with tokio::select!. Keyboard handler maps all specified keys. Agent loop runs in a spawned task. Terminal is initialized and restored cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire main.rs with TUI/headless launch paths</name>
  <files>src/main.rs, src/cli.rs</files>
  <action>
**src/cli.rs** -- Add headless flag:

Add `--headless` flag to the `Run` command variant:
```rust
/// Run the agent loop
Run {
    // ... existing fields ...
    /// Run without TUI (headless mode, original behavior)
    #[arg(long)]
    headless: bool,
}
```

**src/main.rs** -- Branch on headless flag:

Restructure the `Commands::Run` match arm:

```rust
cli::Commands::Run { headless, .. } => {
    let safety = SafetyLayer::new(&config)?;
    // ... existing safety tracing ...

    let shutdown = Arc::new(AtomicBool::new(false));
    let shutdown_clone = shutdown.clone();
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.ok();
        shutdown_clone.store(true, Ordering::SeqCst);
        // Second Ctrl+C: force exit
        tokio::signal::ctrl_c().await.ok();
        std::process::exit(1);
    });

    if headless {
        // Original headless behavior (existing code, unchanged)
        let mut session_number: u32 = 1;
        let mut carryover_messages: Vec<ChatMessage> = Vec::new();
        loop {
            let result = agent::agent_loop::run_agent_session(
                &config, &safety, session_number, &carryover_messages,
                shutdown.clone(), None, None,
            ).await?;
            // ... existing match on result.shutdown_reason (unchanged) ...
        }
    } else {
        // TUI mode (default)
        tui::runner::run_tui(&config, &safety, shutdown).await?;
    }
}
```

Add `mod tui;` to main.rs imports if not already there (it should be via lib.rs, but main.rs has its own module declarations since it's a binary crate -- check existing pattern).

Important: The existing eprintln messages in headless mode should still work. In TUI mode, the TUI owns the terminal so eprintln from the agent loop won't be visible, but that's fine -- the TUI gets all info via events.

Remove the duplicate Ctrl+C shutdown message text from the TUI path (the TUI handles its own quit flow via 'q' key). Keep the Ctrl+C handler simple: just set shutdown flag.
  </action>
  <verify>`cargo check` succeeds. `cargo run -- run --headless --help` shows the headless flag. `cargo test` passes all existing tests.</verify>
  <done>`ouro run` launches TUI mode by default. `ouro run --headless` launches the original headless mode. Both paths compile. Ctrl+C sets shutdown flag in both modes. The TUI path calls run_tui which spawns the agent and runs the render loop.</done>
</task>

</tasks>

<verification>
- `cargo check` passes
- `cargo test` passes all existing tests
- src/tui/input.rs and src/tui/runner.rs exist
- main.rs has TUI and headless branches
- `--headless` flag appears in CLI help
- Key mappings cover: Tab, Shift+Tab, Up, Down, p, e, g, q, y, n, t
</verification>

<success_criteria>
The complete TUI application compiles and links. `ouro run` would launch TUI mode (agent in background task, keyboard controls, real-time rendering). `ouro run --headless` preserves identical behavior to the pre-TUI codebase. Terminal initialization and cleanup are handled by ratatui::init/restore with panic hooks.
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-dashboard/04-04-SUMMARY.md`
</output>
