---
phase: 04-tui-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/agent/agent_loop.rs
  - src/agent/mod.rs
autonomous: true

must_haves:
  truths:
    - "The agent loop sends AgentEvent messages through an mpsc sender for every thought, tool call, tool result, state change, context pressure update, session restart, and error"
    - "The agent loop checks a pause flag between turns and blocks until unpaused"
    - "The agent loop still works identically when no event sender is provided (headless mode)"
  artifacts:
    - path: "src/agent/agent_loop.rs"
      provides: "run_agent_session accepting optional event sender and pause flag"
      contains: "event_tx"
  key_links:
    - from: "src/agent/agent_loop.rs"
      to: "src/tui/event.rs"
      via: "imports AgentEvent and AgentState, sends via mpsc::UnboundedSender"
      pattern: "event_tx.*send.*AgentEvent"
    - from: "src/agent/agent_loop.rs"
      to: "pause_flag"
      via: "Arc<AtomicBool> checked between turns"
      pattern: "pause_flag.*load.*Ordering"
---

<objective>
Refactor the agent loop to emit TUI events via an optional mpsc channel and respect a pause control signal.

Purpose: The agent loop must communicate its state to the TUI without the TUI calling into the agent. This plan adds the event emission points and pause mechanism while preserving headless operation.
Output: Modified agent_loop.rs that optionally sends AgentEvent messages and checks a pause flag.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-dashboard/04-RESEARCH.md
@.planning/phases/04-tui-dashboard/04-CONTEXT.md
@.planning/phases/04-tui-dashboard/04-01-SUMMARY.md
@src/agent/agent_loop.rs
@src/agent/mod.rs
@src/tui/event.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event sender and pause flag to run_agent_session</name>
  <files>src/agent/agent_loop.rs</files>
  <action>
Modify `run_agent_session` signature to accept two new optional parameters:
```rust
pub async fn run_agent_session(
    config: &AppConfig,
    safety: &SafetyLayer,
    session_number: u32,
    carryover_messages: &[ChatMessage],
    shutdown: Arc<AtomicBool>,
    event_tx: Option<tokio::sync::mpsc::UnboundedSender<AgentEvent>>,
    pause_flag: Option<Arc<AtomicBool>>,
) -> anyhow::Result<SessionResult>
```

Add a helper macro or closure at the top of run_agent_session to make event sending ergonomic:
```rust
// Helper: send event if TUI channel exists, ignore send errors (TUI may have closed)
let send_event = |event: AgentEvent| {
    if let Some(ref tx) = event_tx {
        let _ = tx.send(event);
    }
};
```

Add event emissions at these points in the existing loop:

1. **Before streaming** (start of each turn): `send_event(AgentEvent::StateChanged(AgentState::Thinking))`

2. **After stream completes, if text captured**: `send_event(AgentEvent::ThoughtText { timestamp, turn, content })`

3. **Before each tool dispatch**: `send_event(AgentEvent::StateChanged(AgentState::Executing))` and `send_event(AgentEvent::ToolCallStarted { timestamp, turn, call_id, fn_name, args_summary })`

4. **After each tool result**: `send_event(AgentEvent::ToolCallCompleted { timestamp, turn, call_id, fn_name, result_summary, full_result })` where result_summary is the truncated version already computed for eprintln.

5. **After token usage update**: `send_event(AgentEvent::ContextPressure { usage_pct: context_manager.usage_percentage(), prompt_tokens, context_limit: config.context_limit })`

6. **After counters change** (end of each turn): `send_event(AgentEvent::CountersUpdated { turn, tool_calls: tool_call_count })` -- add a `tool_call_count: u64` variable that increments with each dispatched tool call.

7. **On session restart path**: `send_event(AgentEvent::SessionRestarted { session_number })`

8. **On errors**: `send_event(AgentEvent::Error { timestamp, turn, message })`

9. **When entering idle** (between turns, after tool processing): `send_event(AgentEvent::StateChanged(AgentState::Idle))`

Add **pause check** between turns, right after the shutdown check:
```rust
// Check pause flag between turns
if let Some(ref pf) = pause_flag {
    if pf.load(Ordering::SeqCst) {
        send_event(AgentEvent::StateChanged(AgentState::Paused));
        // Spin-wait with small sleep until unpaused or shutdown
        while pf.load(Ordering::SeqCst) && !shutdown.load(Ordering::SeqCst) {
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        if shutdown.load(Ordering::SeqCst) {
            // User quit while paused
            shutdown_reason = "user_shutdown";
            break;
        }
        send_event(AgentEvent::StateChanged(AgentState::Idle));
    }
}
```

Context decision from discuss-phase: "Pause behavior: let current tool finish executing, then pause before next LLM call" -- this is correctly implemented by checking between turns.

The existing eprintln! calls should remain as-is for headless mode. The events are ADDITIONAL, not replacements. When TUI mode is active, the TUI rendering replaces stdout/stderr, but that wiring happens in Plan 04.

Import the needed types:
```rust
use crate::tui::event::{AgentEvent, AgentState};
```
  </action>
  <verify>`cargo check` succeeds. Existing tests still pass: `cargo test --lib agent_loop` (the health check and carryover tests should be unaffected since they don't call the new parameters).</verify>
  <done>run_agent_session accepts optional event_tx and pause_flag. Events are sent at all 9 emission points. Pause check blocks between turns. Passing None for both parameters preserves identical headless behavior. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update call site in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update the `run_agent_session` call in main.rs to pass `None, None` for the two new parameters, preserving current headless behavior:

```rust
let result = agent::agent_loop::run_agent_session(
    &config,
    &safety,
    session_number,
    &carryover_messages,
    shutdown.clone(),
    None,  // event_tx: no TUI in headless mode
    None,  // pause_flag: no pause in headless mode
)
.await?;
```

This is a minimal change that keeps the existing headless flow working while Plan 04 adds the TUI launch path.
  </action>
  <verify>`cargo check` succeeds. `cargo test` all pass (no regressions).</verify>
  <done>main.rs compiles with the updated run_agent_session signature. Headless mode works identically to before.</done>
</task>

</tasks>

<verification>
- `cargo check` passes
- `cargo test` passes (all existing tests)
- run_agent_session has event_tx and pause_flag parameters
- AgentEvent is imported from crate::tui::event
- 9 event emission points exist in agent_loop.rs
- Pause check exists between turns
</verification>

<success_criteria>
The agent loop emits structured events through an optional channel at every significant state change, and respects a pause flag between turns. Headless mode (None, None) is identical to prior behavior. All existing tests pass without modification.
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-dashboard/04-02-SUMMARY.md`
</output>
