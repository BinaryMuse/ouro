---
phase: 04-tui-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tui/mod.rs
  - src/tui/event.rs
  - src/tui/app_state.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "AppEvent enum covers all agent-observable events (thought, tool call, tool result, state change, context pressure, session restart, error, discovery, counters)"
    - "AppState struct accumulates events into renderable state with log entries, agent state, counters, context pressure, and discoveries"
    - "ControlSignal enum supports Pause, Resume, and Quit"
    - "ratatui 0.30 and tui-tree-widget 0.24 compile successfully"
  artifacts:
    - path: "src/tui/event.rs"
      provides: "AgentEvent, AgentState, ControlSignal enums"
      exports: ["AgentEvent", "AgentState", "ControlSignal"]
    - path: "src/tui/app_state.rs"
      provides: "AppState struct with log entries, apply_event method, tab state, scroll state"
      exports: ["AppState", "LogEntry", "LogEntryKind"]
    - path: "src/tui/mod.rs"
      provides: "Module root re-exporting public types"
    - path: "Cargo.toml"
      provides: "ratatui and tui-tree-widget dependencies"
      contains: "ratatui"
  key_links:
    - from: "src/tui/app_state.rs"
      to: "src/tui/event.rs"
      via: "AppState::apply_event takes AgentEvent"
      pattern: "fn apply_event.*AgentEvent"
---

<objective>
Create the TUI type foundation: event types, application state, control signals, and add ratatui dependencies.

Purpose: All other TUI plans depend on these shared types. The event enum defines the contract between the agent loop and the TUI. The AppState struct defines how events accumulate into renderable state.
Output: src/tui/ module with event.rs (AgentEvent, AgentState, ControlSignal) and app_state.rs (AppState with apply_event).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-dashboard/04-RESEARCH.md
@.planning/phases/04-tui-dashboard/04-CONTEXT.md
@Cargo.toml
@src/lib.rs
@src/agent/mod.rs
@src/agent/logging.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TUI dependencies and scaffold tui module</name>
  <files>Cargo.toml, src/tui/mod.rs, src/lib.rs</files>
  <action>
Add to Cargo.toml [dependencies]:
- ratatui = { version = "0.30", features = ["crossterm"] }
- tui-tree-widget = "0.24"

Create src/tui/mod.rs as the module root:
```rust
pub mod app_state;
pub mod event;
```

Add `pub mod tui;` to src/lib.rs (after existing modules).

Run `cargo check` to verify the new dependencies compile. If tui-tree-widget 0.24 has compatibility issues with ratatui 0.30, try 0.22 or 0.23 instead. The research flagged this as needing compile-time verification.

Do NOT add crossterm as a direct dependency -- use the `ratatui::crossterm` re-export to avoid version conflicts (per research pitfall #2).
  </action>
  <verify>`cargo check` succeeds with new dependencies.</verify>
  <done>ratatui and tui-tree-widget are in Cargo.toml, src/tui/mod.rs exists, lib.rs re-exports it, `cargo check` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create event types and AppState</name>
  <files>src/tui/event.rs, src/tui/app_state.rs</files>
  <action>
**src/tui/event.rs** -- Define the event/signal types that form the contract between agent loop and TUI:

```rust
/// Events emitted by the agent loop, sent via mpsc channel to the TUI.
pub enum AgentEvent {
    ThoughtText { timestamp: String, turn: u64, content: String },
    ToolCallStarted { timestamp: String, turn: u64, call_id: String, fn_name: String, args_summary: String },
    ToolCallCompleted { timestamp: String, turn: u64, call_id: String, fn_name: String, result_summary: String, full_result: String },
    StateChanged(AgentState),
    ContextPressure { usage_pct: f64, prompt_tokens: usize, context_limit: usize },
    SessionRestarted { session_number: u32 },
    Error { timestamp: String, turn: u64, message: String },
    Discovery { timestamp: String, content: String },
    CountersUpdated { turn: u64, tool_calls: u64 },
}

/// The four visible agent states shown in the status bar.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AgentState {
    Thinking,
    Executing,
    Idle,
    Paused,
}

/// Control signals sent from TUI to agent loop.
#[derive(Debug, Clone, Copy)]
pub enum ControlSignal {
    Pause,
    Resume,
    Quit,
}
```

Derive Debug and Clone on AgentEvent. Implement Display for AgentState (returns "Thinking", "Executing", "Idle", "Paused").

**src/tui/app_state.rs** -- Define the accumulator that turns events into renderable state:

Define a TUI-local LogEntry struct (not the JSONL one from agent::logging):
```rust
pub enum LogEntryKind {
    Thought,
    ToolCall,
    ToolResult,
    Error,
    SessionSeparator,
    System,
}

pub struct LogEntry {
    pub timestamp: String,
    pub kind: LogEntryKind,
    pub summary: String,       // One-line summary (always visible)
    pub full_content: String,  // Full content (visible when expanded)
    pub expanded: bool,        // Whether this entry is expanded (tool results default false)
}
```

Define AppState:
```rust
pub struct AppState {
    pub log_entries: Vec<LogEntry>,
    pub discoveries: Vec<(String, String)>,  // (timestamp, content)
    pub agent_state: AgentState,
    pub context_usage_pct: f64,
    pub prompt_tokens: usize,
    pub context_limit: usize,
    pub session_number: u32,
    pub turn_count: u64,
    pub tool_call_count: u64,
    pub active_tab: usize,          // 0 = Agent, 1 = Discoveries
    pub log_scroll_offset: usize,
    pub auto_scroll: bool,
    pub sub_agent_panel_visible: bool,
    pub quit_pending: bool,          // true after first 'q' press, waiting for confirmation
}
```

Implement:
- `AppState::new()` -- defaults: agent_state=Idle, auto_scroll=true, sub_agent_panel_visible=true, active_tab=0, session_number=1
- `AppState::apply_event(&mut self, event: AgentEvent)` -- match on event variants, push log entries, update counters/state. For ToolCallStarted: push a LogEntry with kind=ToolCall, expanded=false. For ToolCallCompleted: push LogEntry with kind=ToolResult, expanded=false, summary shows "{fn_name}: {N} lines of output" (count newlines in full_result). For ThoughtText: push with kind=Thought, expanded=true. For SessionRestarted: push separator log entry. For StateChanged: update agent_state. For ContextPressure: update usage fields. For CountersUpdated: update turn/tool counts. For Error: push with kind=Error.
- `AppState::toggle_expand(&mut self, index: usize)` -- flip expanded bool on log_entries[index]
- `AppState::scroll_up(&mut self)` / `scroll_down(&mut self)` -- adjust log_scroll_offset, set auto_scroll=false on scroll_up
- `AppState::jump_to_bottom(&mut self)` -- set log_scroll_offset to end, auto_scroll=true

Add `use super::event::{AgentEvent, AgentState};` at top.
  </action>
  <verify>`cargo check` succeeds. Verify event.rs and app_state.rs export the expected types by checking that `use ouro::tui::event::AgentEvent;` resolves (via a quick test or cargo check).</verify>
  <done>AgentEvent has 9 variants matching the research spec. AgentState has 4 variants with Display impl. ControlSignal has 3 variants. AppState has apply_event that handles all AgentEvent variants. All types compile cleanly.</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- src/tui/mod.rs, src/tui/event.rs, src/tui/app_state.rs all exist
- ratatui = "0.30" appears in Cargo.toml
- `pub mod tui;` appears in src/lib.rs
</verification>

<success_criteria>
The TUI type foundation compiles and exports AgentEvent, AgentState, ControlSignal, AppState, and LogEntry types that subsequent plans can import. No rendering code yet -- just the data layer.
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-dashboard/04-01-SUMMARY.md`
</output>
