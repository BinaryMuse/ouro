---
phase: 05-sub-agent-orchestration
plan: 04
type: execute
wave: 4
depends_on: ["05-01", "05-03"]
files_modified:
  - src/tui/tabs/agent_tab.rs
  - src/tui/app_state.rs
  - src/tui/event.rs
  - src/tui/runner.rs
  - src/main.rs
  - src/agent/agent_loop.rs
autonomous: true

must_haves:
  truths:
    - "SubAgentManager is created at harness level in main.rs and survives across session restarts"
    - "SubAgentManager is passed through to agent_loop and tool dispatch"
    - "TUI sub-agent panel shows a hierarchical tree of sub-agents with status indicators"
    - "Harness shutdown cancels all sub-agents and background processes via root CancellationToken"
    - "SubAgentManager shutdown_all is called before the harness exits"
  artifacts:
    - path: "src/main.rs"
      provides: "SubAgentManager creation and shutdown integration"
      contains: "SubAgentManager"
    - path: "src/tui/runner.rs"
      provides: "SubAgentManager passed to agent loop and TUI state"
      contains: "SubAgentManager"
    - path: "src/tui/tabs/agent_tab.rs"
      provides: "Real sub-agent tree rendering replacing Phase 5 placeholder"
    - path: "src/tui/app_state.rs"
      provides: "Sub-agent tree data fields and event handling"
    - path: "src/agent/agent_loop.rs"
      provides: "SubAgentManager parameter threaded through to tool dispatch"
  key_links:
    - from: "src/main.rs"
      to: "src/orchestration/manager.rs"
      via: "creates SubAgentManager with root CancellationToken"
      pattern: "SubAgentManager::new"
    - from: "src/tui/runner.rs"
      to: "src/orchestration/manager.rs"
      via: "passes manager to agent loop and reads state for TUI"
      pattern: "manager"
    - from: "src/agent/agent_loop.rs"
      to: "src/agent/tools.rs"
      via: "passes manager to dispatch_tool_call"
      pattern: "dispatch_tool_call.*manager"
    - from: "src/tui/tabs/agent_tab.rs"
      to: "tui-tree-widget"
      via: "renders Tree widget from sub-agent data"
      pattern: "Tree|TreeItem|TreeState"
---

<objective>
Wire the SubAgentManager into the harness lifecycle (main.rs, runner.rs, agent_loop.rs) and replace the TUI sub-agent placeholder with a real hierarchical tree view.

Purpose: This is the integration plan that connects the orchestration module to the rest of the harness. The SubAgentManager must live at the harness level (not per-session) so sub-agents survive context restarts. The TUI must show real-time sub-agent status using the tui-tree-widget already in dependencies. Tool dispatch must receive the manager so tool calls reach the orchestration layer.

Output: Fully integrated orchestration with main.rs lifecycle, TUI tree rendering, and agent_loop threading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sub-agent-orchestration/05-RESEARCH.md
@.planning/phases/05-sub-agent-orchestration/05-CONTEXT.md
@.planning/phases/05-sub-agent-orchestration/05-01-SUMMARY.md
@.planning/phases/05-sub-agent-orchestration/05-02-SUMMARY.md
@.planning/phases/05-sub-agent-orchestration/05-03-SUMMARY.md
@src/main.rs
@src/tui/runner.rs
@src/tui/tabs/agent_tab.rs
@src/tui/app_state.rs
@src/tui/event.rs
@src/agent/agent_loop.rs
@src/agent/tools.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire SubAgentManager into main.rs, runner.rs, and agent_loop.rs</name>
  <files>
    src/main.rs
    src/tui/runner.rs
    src/agent/agent_loop.rs
  </files>
  <action>
1. **main.rs changes:**

   a. Import SubAgentManager and CancellationToken:
      ```rust
      use tokio_util::sync::CancellationToken;
      use crate::orchestration::manager::SubAgentManager;
      ```
      Note: main.rs uses `mod` declarations not `crate::`, so adjust imports accordingly for the binary crate.

   b. In the `Run` command handler, BEFORE the headless/TUI branch:
      - Create a root CancellationToken: `let root_cancel = CancellationToken::new();`
      - Create SubAgentManager: `let manager = SubAgentManager::new(root_cancel.clone(), Some(event_tx.clone()), 3, 10);`
      Wait -- event_tx is created inside run_tui, not in main.rs. The manager needs to be created in main.rs (harness level) but the event_tx doesn't exist until TUI starts. Solution: create the manager without event_tx initially, and have run_tui set it later, OR pass the manager to run_tui which creates its own event channel and sets it on the manager. OR simpler: create manager with event_tx as None in main.rs, and let run_tui update it.

      Actually the cleanest approach: Create the manager in main.rs with event_tx = None. Pass it to both headless and TUI paths. For TUI mode, run_tui can access the manager and send events through its own channel (reading manager state during render ticks).

      ```rust
      let root_cancel = CancellationToken::new();
      let manager = SubAgentManager::new(root_cancel.clone(), None, 3, 10);
      ```

   c. In the headless branch, pass `manager.clone()` to `run_agent_session`. Also connect the shutdown AtomicBool to the root_cancel token: when shutdown is set, also cancel the root token.

   d. In the TUI branch, pass `manager.clone()` to `run_tui`.

   e. AFTER the headless/TUI loop exits, call `manager.shutdown_all().await` to clean up any remaining sub-agents/processes. Then cancel the root token if not already cancelled.

   f. Wire the shutdown AtomicBool to also cancel the root_cancel token. In the Ctrl+C handler: `root_cancel.cancel()` alongside `shutdown.store(true)`.

2. **agent_loop.rs changes:**

   a. Add `manager: SubAgentManager` parameter to `run_agent_session`:
      ```rust
      pub async fn run_agent_session(
          config: &AppConfig,
          safety: &SafetyLayer,
          session_number: u32,
          carryover_messages: &[ChatMessage],
          shutdown: Arc<AtomicBool>,
          event_tx: Option<tokio::sync::mpsc::UnboundedSender<AgentEvent>>,
          pause_flag: Option<Arc<AtomicBool>>,
          manager: SubAgentManager,
      ) -> anyhow::Result<SessionResult>
      ```

   b. Update the `define_tools()` call to `define_tools(None)` (no filter for root agent).

   c. Update the `dispatch_tool_call()` calls to pass `Some(&manager)` and `Some(config)`.

   d. No other changes to agent_loop logic -- all sub-agent interaction happens through tool dispatch.

3. **runner.rs changes:**

   a. Add `manager: SubAgentManager` parameter to `run_tui`:
      ```rust
      pub async fn run_tui(
          config: &AppConfig,
          _safety: &SafetyLayer,
          shutdown: Arc<AtomicBool>,
          manager: SubAgentManager,
      ) -> anyhow::Result<()>
      ```

   b. Pass `manager.clone()` to the spawned agent loop task (where it calls `run_agent_session`).

   c. Store manager reference in the main loop scope so the render tick can query sub-agent state.

   d. In the render tick, before calling `render_ui`, update AppState with current sub-agent info from manager:
      ```rust
      app_state.sub_agent_entries = manager.list_all();
      ```
      Add `sub_agent_entries: Vec<SubAgentInfo>` field to AppState.

4. Update ALL existing call sites of `run_agent_session` (main.rs headless path, runner.rs TUI path) to pass the manager parameter.
  </action>
  <verify>
    `cargo check` passes. `cargo test` passes (agent_loop tests may need manager parameter added -- use a test helper that creates a minimal SubAgentManager).
  </verify>
  <done>SubAgentManager flows from main.rs through to agent_loop's tool dispatch. TUI runner has access to manager for sub-agent state queries. Shutdown path cancels root token and awaits cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Replace TUI sub-agent placeholder with tree widget</name>
  <files>
    src/tui/tabs/agent_tab.rs
    src/tui/app_state.rs
    src/tui/event.rs
  </files>
  <action>
1. **app_state.rs changes:**

   a. Add `use crate::orchestration::types::SubAgentInfo;` import.

   b. Add field to AppState:
      ```rust
      pub sub_agent_entries: Vec<SubAgentInfo>,
      ```
      Initialize to empty Vec in `new()`.

   c. Handle `AgentEvent::SubAgentStatusChanged` in `apply_event`:
      - This event is just a notification -- the actual data comes from manager.list_all() which is called by the render tick in runner.rs. So the handler can be a no-op, or it can trigger a flag to refresh on next tick. Simplest: no-op (the render tick refreshes every 50ms anyway).

2. **event.rs changes:**

   The `SubAgentStatusChanged` variant was already added in plan 01 (Task 2). Verify it exists. If not present, add it:
   ```rust
   SubAgentStatusChanged {
       agent_id: String,
       status: String,
       kind: String,
   },
   ```

3. **agent_tab.rs changes:**

   Replace `render_sub_agent_placeholder` with a real tree widget rendering function:

   a. Import tui-tree-widget types:
      ```rust
      use tui_tree_widget::{Tree, TreeItem, TreeState};
      use crate::orchestration::types::{SubAgentInfo, SubAgentStatus, SubAgentKind};
      ```

   b. Create function `build_sub_agent_tree_items(entries: &[SubAgentInfo]) -> Vec<TreeItem<'static, String>>`:
      - Group entries: root entries (parent_id == None) are top-level items
      - For each root entry, find its children (entries where parent_id == Some(root.id))
      - Recursively build children's children
      - Format each item as: `{status_icon} {kind_label}: {description} ({status})`
        - Status icons: Running = "[*]", Completed = "[+]", Failed = "[!]", Killed = "[x]"
        - Kind label: "LLM" for LlmSession, "Proc" for BackgroundProcess
        - Description: goal string for LLM, command for background process (truncated to 40 chars)
      - Create TreeItem with children

   c. Update `render_agent_tab` to use the tree widget:
      - If `state.sub_agent_entries.is_empty()` AND `state.sub_agent_panel_visible`, show a dim "(No sub-agents running)" message instead of the placeholder
      - If entries exist, render a `Tree` widget with the built items
      - Use `TreeState::default()` for now (no interactive selection needed yet)
      - Style: bordered block with title " Sub-Agents ", tree items colored by status (green=completed, yellow=running, red=failed, gray=killed)

   d. Remove the old `render_sub_agent_placeholder` function entirely.

   e. Update tests:
      - Remove the test that checks for "Phase 5" text in the placeholder
      - Add test: render_agent_tab with empty sub_agent_entries shows "No sub-agents" message
      - Add test: render_agent_tab with sub_agent_entries shows tree content
  </action>
  <verify>
    `cargo check` passes. `cargo test --lib tui` passes with updated tests. The placeholder text "(No sub-agents -- Phase 5)" no longer appears anywhere in the codebase.
  </verify>
  <done>TUI sub-agent panel renders a real hierarchical tree of sub-agents with status icons and color coding, using tui-tree-widget. The Phase 5 placeholder is fully replaced.</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `cargo test` passes (all existing tests updated for new parameter)
- SubAgentManager is created in main.rs and passed through runner/agent_loop
- Ctrl+C cancels root CancellationToken in addition to setting shutdown flag
- manager.shutdown_all() is called before harness exits
- TUI sub-agent panel shows tree widget (not placeholder)
- grep -r "Phase 5" src/ returns no placeholder matches
</verification>

<success_criteria>
The orchestration module is fully integrated into the harness: SubAgentManager lives at harness level, survives session restarts, connects to tool dispatch, renders in the TUI tree panel, and shuts down cleanly with the harness.
</success_criteria>

<output>
After completion, create `.planning/phases/05-sub-agent-orchestration/05-04-SUMMARY.md`
</output>
