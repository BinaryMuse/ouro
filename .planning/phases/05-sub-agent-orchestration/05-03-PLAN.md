---
phase: 05-sub-agent-orchestration
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/agent/tools.rs
  - src/agent/system_prompt.rs
autonomous: true

must_haves:
  truths:
    - "Agent can invoke spawn_llm_session tool and receive back a sub-agent ID"
    - "Agent can invoke spawn_background_task tool and receive back a process ID"
    - "Agent can query agent_status and see all sub-agents with their current status"
    - "Agent can retrieve a completed sub-agent's result via agent_result tool"
    - "Agent can kill a running sub-agent via kill_agent tool"
    - "Agent can write to a background process stdin via write_stdin tool"
  artifacts:
    - path: "src/agent/tools.rs"
      provides: "Six new tool schemas and dispatch routing"
      exports: ["define_tools", "dispatch_tool_call"]
    - path: "src/agent/system_prompt.rs"
      provides: "Updated tool descriptions including sub-agent tools"
  key_links:
    - from: "src/agent/tools.rs"
      to: "src/orchestration/llm_agent.rs"
      via: "dispatch calls spawn_llm_sub_agent"
      pattern: "spawn_llm_sub_agent"
    - from: "src/agent/tools.rs"
      to: "src/orchestration/background_proc.rs"
      via: "dispatch calls spawn_background_process"
      pattern: "spawn_background_process"
    - from: "src/agent/tools.rs"
      to: "src/orchestration/manager.rs"
      via: "dispatch queries SubAgentManager for status/result/kill/stdin"
      pattern: "manager\\."
---

<objective>
Add six new tool schemas to the agent's tool set and wire their dispatch to the orchestration module.

Purpose: The agent interacts with sub-agents exclusively through tools. This plan adds the tool schemas (so the LLM knows they exist), the dispatch routing (so tool calls reach the orchestration layer), and updates the system prompt tool descriptions. The agent will be able to spawn, monitor, retrieve results from, kill, and interact with sub-agents and background processes.

Output: Extended `src/agent/tools.rs` with six new tools fully dispatched, updated tool descriptions in system_prompt.rs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sub-agent-orchestration/05-RESEARCH.md
@.planning/phases/05-sub-agent-orchestration/05-CONTEXT.md
@.planning/phases/05-sub-agent-orchestration/05-01-SUMMARY.md
@.planning/phases/05-sub-agent-orchestration/05-02-SUMMARY.md
@src/agent/tools.rs
@src/agent/system_prompt.rs
@src/orchestration/types.rs
@src/orchestration/manager.rs
@src/orchestration/llm_agent.rs
@src/orchestration/background_proc.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tool schemas and dispatch for all six sub-agent tools</name>
  <files>
    src/agent/tools.rs
  </files>
  <action>
Modify `src/agent/tools.rs` to add six new tools. The function signatures must change to accept a SubAgentManager parameter.

1. Update `define_tools()` to accept an optional filter parameter and return the full tool set:
   ```rust
   pub fn define_tools(filter: Option<&[String]>) -> Vec<Tool>
   ```
   When filter is None, return all tools (original 3 + 6 new). When filter is Some, return only tools whose names are in the filter list. This enables sub-agents to have a customized tool set (user decision).

   Add these 6 new Tool definitions to the returned Vec:

   a. `spawn_llm_session`:
      - description: "Spawn a child LLM chat session that runs concurrently. Returns the sub-agent ID for status tracking."
      - schema properties: goal (string, required), model (string, optional -- defaults to current model), context (object with string values, optional -- key-value context injected into sub-agent prompt), timeout_secs (integer, optional), tools (array of strings, optional -- tool names to enable)
      - required: ["goal"]

   b. `spawn_background_task`:
      - description: "Spawn a background shell process that runs independently. Returns the process ID for monitoring."
      - schema properties: command (string, required)
      - required: ["command"]

   c. `agent_status`:
      - description: "Query the status of all sub-agents and background processes, or a specific one by ID."
      - schema properties: agent_id (string, optional -- if omitted, returns all)

   d. `agent_result`:
      - description: "Retrieve the structured result of a completed sub-agent. Returns error if agent is still running."
      - schema properties: agent_id (string, required)
      - required: ["agent_id"]

   e. `kill_agent`:
      - description: "Terminate a running sub-agent or background process."
      - schema properties: agent_id (string, required)
      - required: ["agent_id"]

   f. `write_stdin`:
      - description: "Write data to a running background process's stdin. Useful for interactive programs."
      - schema properties: agent_id (string, required), data (string, required)
      - required: ["agent_id", "data"]

2. Update `dispatch_tool_call` signature to accept SubAgentManager:
   ```rust
   pub async fn dispatch_tool_call(
       call: &genai::chat::ToolCall,
       safety: &SafetyLayer,
       workspace: &Path,
       manager: Option<&SubAgentManager>,
       config: Option<&AppConfig>,
   ) -> String
   ```
   The manager and config are Option so that existing call sites (tests, sub-agents without manager access) still work. When None and a sub-agent tool is called, return `{"error": "Sub-agent tools not available"}`.

3. Add dispatch arms in the match:
   - "spawn_llm_session" -> extract goal, model, context, timeout_secs, tools from fn_arguments. Call `spawn_llm_sub_agent`. Return `{"agent_id": "uuid", "status": "spawned"}` on success.
   - "spawn_background_task" -> extract command. Call `spawn_background_process`. Return `{"agent_id": "uuid", "status": "spawned"}`.
   - "agent_status" -> extract optional agent_id. If provided, call `manager.get_status(id)` and serialize. If not, call `manager.list_all()` and serialize as JSON array.
   - "agent_result" -> extract agent_id. Call `manager.get_result(id)`. Return the SubAgentResult JSON or `{"error": "No result available (agent may still be running)"}`.
   - "kill_agent" -> extract agent_id. Call `manager.cancel_agent(id)`. Return `{"killed": true}` or `{"error": "Agent not found"}`.
   - "write_stdin" -> extract agent_id and data. Call `manager.take_stdin(id)`, write data + newline via `AsyncWriteExt::write_all`, then put stdin back... Actually, take_stdin removes the handle permanently. Instead, the manager should provide a `write_to_stdin` method. Add this method to SubAgentManager in this task:
     ```rust
     pub async fn write_to_stdin(&self, id: &SubAgentId, data: &[u8]) -> Result<(), String>
     ```
     This locks the entry, takes a mutable reference to the ChildStdin (using as_mut() on the Option), and writes. It does NOT consume the handle.
     Return `{"written_bytes": N}` on success or `{"error": "..."}` on failure.

4. Update existing tests to pass None for the new manager/config parameters in dispatch_tool_call calls.

IMPORTANT: The `parent_id` for sub-agent spawning from the root agent should be `None` (root agent is not tracked in the manager). Sub-agents spawning their own children would pass their own ID as parent_id -- but that happens inside the sub-agent's own tool dispatch, which receives the sub-agent's ID through its own scope.

IMPORTANT: For write_stdin, do NOT use take_stdin (which removes the handle). Instead, modify the SubAgentEntry to hold `Option<Arc<Mutex<ChildStdin>>>` so multiple writes can happen. Or simpler: add a `write_to_stdin` method on SubAgentManager that temporarily takes the ChildStdin, writes, and puts it back. The cleanest approach is wrapping ChildStdin in `Arc<Mutex<>>` in the manager entry -- update manager.rs set_stdin to accept `Arc<Mutex<ChildStdin>>` and background_proc.rs to wrap it accordingly.
  </action>
  <verify>
    `cargo check` passes. `cargo test --lib agent::tools` passes (existing tests updated for new signatures). The six new tool schemas appear in define_tools() output.
  </verify>
  <done>All six sub-agent tools have schemas in define_tools(), dispatch routing in dispatch_tool_call(), and the existing tool tests pass with the updated signatures.</done>
</task>

<task type="auto">
  <name>Task 2: Update tool descriptions in system prompt</name>
  <files>
    src/agent/tools.rs
    src/agent/system_prompt.rs
  </files>
  <action>
1. Update the `tool_descriptions()` function in `src/agent/tools.rs` to include descriptions for the six new tools. Follow the existing format (markdown with ### headers, parameter lists, and return descriptions). Add after the existing file_write description:

```
### spawn_llm_session
Spawn a child LLM chat session that runs concurrently.
- **goal** (string, required): What the sub-agent should accomplish
- **model** (string, optional): Ollama model name (defaults to your model)
- **context** (object, optional): Key-value context injected into the sub-agent's prompt
- **timeout_secs** (integer, optional): Maximum runtime in seconds
- **tools** (array of strings, optional): Tool names to enable (default: all your tools)
- Returns: JSON with agent_id and status fields
- The sub-agent runs independently and you can check its progress via agent_status

### spawn_background_task
Spawn a background shell process that runs independently.
- **command** (string, required): The shell command to run
- Returns: JSON with agent_id and status fields
- The process runs in the background; use agent_status to check progress
- Use write_stdin to send input to the process

### agent_status
Query the status of sub-agents and background processes.
- **agent_id** (string, optional): Specific agent ID to query (omit for all)
- Returns: JSON with agent info including status (running/completed/failed/killed)

### agent_result
Retrieve the structured result of a completed sub-agent.
- **agent_id** (string, required): The agent ID to retrieve results for
- Returns: JSON with summary, output, files_modified, elapsed_secs
- Returns error if the agent is still running

### kill_agent
Terminate a running sub-agent or background process.
- **agent_id** (string, required): The agent ID to terminate
- Returns: JSON with killed status

### write_stdin
Write data to a running background process's stdin.
- **agent_id** (string, required): The background process ID
- **data** (string, required): Data to write (newline appended automatically)
- Returns: JSON with written_bytes
```

2. Verify that `build_system_prompt` in `src/agent/system_prompt.rs` uses `tool_descriptions()` so the new descriptions are automatically included. Check the existing code -- if it already calls `tool_descriptions()`, no changes needed to system_prompt.rs.
  </action>
  <verify>
    `cargo check` passes. `cargo test --lib agent::tools::tests::tool_descriptions_contains_all_tools` passes (update the test to check for new tool names too).
  </verify>
  <done>tool_descriptions() returns markdown descriptions for all 9 tools (3 original + 6 new), and the tool_descriptions test validates all tool names are present.</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `cargo test --lib agent::tools` passes (all existing + new tests)
- `define_tools(None)` returns 9 tools
- `define_tools(Some(&["shell_exec".into(), "file_read".into()]))` returns 2 tools
- `dispatch_tool_call` routes all 6 new tool names to orchestration module
- `tool_descriptions()` contains descriptions for all 9 tools
</verification>

<success_criteria>
The agent has access to all six sub-agent tools via tool schemas, dispatch routing connects to the orchestration module, and tool descriptions are included in the system prompt. Existing tool tests pass with updated signatures.
</success_criteria>

<output>
After completion, create `.planning/phases/05-sub-agent-orchestration/05-03-SUMMARY.md`
</output>
