---
phase: 05-sub-agent-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/orchestration/mod.rs
  - src/orchestration/types.rs
  - src/orchestration/manager.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "SubAgentManager can be constructed and wrapped in Arc for shared ownership"
    - "Sub-agents and background processes can be registered with unique IDs and queried by status"
    - "CancellationToken hierarchy enables cascading shutdown from root to all children"
    - "Depth and total count limits are enforced when registering new entries"
  artifacts:
    - path: "src/orchestration/mod.rs"
      provides: "Module exports for orchestration subsystem"
    - path: "src/orchestration/types.rs"
      provides: "SubAgentId, SubAgentKind, SubAgentStatus, SubAgentInfo, SubAgentResult, BackgroundProcessInfo"
      exports: ["SubAgentId", "SubAgentKind", "SubAgentStatus", "SubAgentInfo", "SubAgentResult"]
    - path: "src/orchestration/manager.rs"
      provides: "SubAgentManager with registry, spawn registration, status query, cleanup"
      exports: ["SubAgentManager"]
    - path: "Cargo.toml"
      provides: "tokio-util and uuid dependencies"
      contains: "tokio-util"
  key_links:
    - from: "src/orchestration/manager.rs"
      to: "src/orchestration/types.rs"
      via: "uses type definitions"
      pattern: "use.*types::"
    - from: "src/lib.rs"
      to: "src/orchestration/mod.rs"
      via: "pub mod orchestration"
      pattern: "pub mod orchestration"
---

<objective>
Create the orchestration module foundation: type definitions, SubAgentManager registry, and new dependencies.

Purpose: The SubAgentManager is the single source of truth for all spawned sub-agents and background processes. Every subsequent plan depends on these types and the manager's API. This plan establishes the data structures, the shared registry with Arc-wrapped concurrent access, CancellationToken hierarchy for cascading shutdown, and depth/count safety limits.

Output: `src/orchestration/` module with types.rs and manager.rs, updated Cargo.toml with tokio-util and uuid dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sub-agent-orchestration/05-RESEARCH.md
@.planning/phases/05-sub-agent-orchestration/05-CONTEXT.md
@src/lib.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create orchestration types</name>
  <files>
    Cargo.toml
    src/orchestration/mod.rs
    src/orchestration/types.rs
    src/lib.rs
  </files>
  <action>
1. Add new dependencies to Cargo.toml:
   ```toml
   tokio-util = { version = "0.7", features = ["sync"] }
   uuid = { version = "4", features = ["v4"] }
   ```

2. Create `src/orchestration/mod.rs` exporting submodules:
   ```rust
   pub mod types;
   pub mod manager;
   ```

3. Create `src/orchestration/types.rs` with these types:

   - `pub type SubAgentId = String;` (UUID string for readability in logs/tools)

   - `SubAgentKind` enum (Clone, Debug, Serialize):
     - `LlmSession { model: String, goal: String }`
     - `BackgroundProcess { command: String }`

   - `SubAgentStatus` enum (Clone, Debug, PartialEq, Eq, Serialize):
     - `Running`
     - `Completed`
     - `Failed(String)`
     - `Killed`

   - `SubAgentInfo` struct (Clone, Debug, Serialize) -- the read-only view returned by status queries:
     - `id: SubAgentId`
     - `kind: SubAgentKind`
     - `parent_id: Option<SubAgentId>`
     - `status: SubAgentStatus`
     - `depth: usize` (nesting depth, root = 0)
     - `spawned_at: String` (ISO timestamp)
     - `completed_at: Option<String>`

   - `SubAgentResult` struct (Clone, Debug, Serialize, Deserialize) -- the structured result returned when a sub-agent completes:
     - `agent_id: SubAgentId`
     - `status: String` ("completed" or "failed")
     - `summary: String`
     - `output: String`
     - `files_modified: Vec<String>`
     - `elapsed_secs: f64`

   All types should derive Serialize (serde) for JSON tool responses. SubAgentResult also derives Deserialize.

4. Add `pub mod orchestration;` to `src/lib.rs`.

Do NOT use DashMap -- use `Arc<Mutex<HashMap>>` for simplicity (per research: "simpler but may contend" -- contention is negligible for this use case with <20 concurrent agents). This avoids adding another dependency.
  </action>
  <verify>
    `cargo check` passes with no errors. `src/orchestration/types.rs` exists with all type definitions. `src/lib.rs` contains `pub mod orchestration`.
  </verify>
  <done>All orchestration types are defined, derive Serialize, and the module compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SubAgentManager registry</name>
  <files>
    src/orchestration/manager.rs
  </files>
  <action>
Create `src/orchestration/manager.rs` implementing the central registry:

```rust
pub struct SubAgentManager {
    entries: Arc<Mutex<HashMap<SubAgentId, SubAgentEntry>>>,
    root_cancel_token: CancellationToken,
    event_tx: Option<UnboundedSender<AgentEvent>>,
    max_depth: usize,   // default 3
    max_total: usize,   // default 10
}
```

Where `SubAgentEntry` is a private struct holding:
- `info: SubAgentInfo` (the read-only view)
- `cancel_token: CancellationToken` (child of parent's token)
- `join_handle: Option<JoinHandle<()>>` (for cleanup)
- `result: Option<SubAgentResult>` (set on completion)
- `stdin_handle: Option<tokio::process::ChildStdin>` (for background processes)
- `output_buffer: Option<Arc<Mutex<VecDeque<String>>>>` (for background process output, ring buffer)

Implement these methods on SubAgentManager:

1. `pub fn new(root_cancel_token: CancellationToken, event_tx: Option<UnboundedSender<AgentEvent>>, max_depth: usize, max_total: usize) -> Self`

2. `pub fn register(&self, id: SubAgentId, kind: SubAgentKind, parent_id: Option<SubAgentId>, cancel_token: CancellationToken) -> Result<(), String>` -- validates depth (by walking parent chain) and total count limits before inserting. Returns Err if limits exceeded.

3. `pub fn set_join_handle(&self, id: &SubAgentId, handle: JoinHandle<()>)`

4. `pub fn set_stdin(&self, id: &SubAgentId, stdin: tokio::process::ChildStdin)`

5. `pub fn set_output_buffer(&self, id: &SubAgentId, buf: Arc<Mutex<VecDeque<String>>>)`

6. `pub fn update_status(&self, id: &SubAgentId, status: SubAgentStatus)` -- also sets completed_at timestamp when status is Completed/Failed/Killed. Emits `AgentEvent::SubAgentStatusChanged` via event_tx if available.

7. `pub fn set_result(&self, id: &SubAgentId, result: SubAgentResult)`

8. `pub fn get_status(&self, id: &SubAgentId) -> Option<SubAgentInfo>` -- returns a clone of the info.

9. `pub fn get_result(&self, id: &SubAgentId) -> Option<SubAgentResult>`

10. `pub fn list_all(&self) -> Vec<SubAgentInfo>` -- returns all entries' info clones.

11. `pub fn children_of(&self, parent_id: &SubAgentId) -> Vec<SubAgentInfo>` -- returns children of a given parent.

12. `pub fn root_agents(&self) -> Vec<SubAgentInfo>` -- returns entries with parent_id == None.

13. `pub fn cancel_agent(&self, id: &SubAgentId) -> bool` -- cancels the agent's token and updates status to Killed. Returns true if found.

14. `pub async fn shutdown_all(&self)` -- cancels root token, then awaits all JoinHandles with a 5-second timeout per handle. Any remaining processes are killed via the cancel tokens.

15. `pub fn create_child_token(&self, parent_id: Option<&SubAgentId>) -> CancellationToken` -- if parent_id is Some and found, creates child_token of that agent's token. Otherwise creates child_token of root.

16. `pub fn take_stdin(&self, id: &SubAgentId) -> Option<tokio::process::ChildStdin>` -- takes (removes) the stdin handle for writing. Returns None if not found or already taken.

17. `pub fn read_output(&self, id: &SubAgentId, tail_lines: usize) -> Option<Vec<String>>` -- reads last N lines from the output buffer.

18. `pub fn total_count(&self) -> usize`

19. `pub fn depth_of(&self, id: &SubAgentId) -> Option<usize>`

The manager should be Clone (all fields are Arc or Clone). Wrap in `Arc` by convention in docs, but the struct itself should be Clone since all its internal state is already behind Arc.

Add the new `AgentEvent::SubAgentStatusChanged` variant to `src/tui/event.rs`:
```rust
SubAgentStatusChanged {
    agent_id: String,
    status: String,
    kind: String,
}
```
And handle it in `src/tui/app_state.rs` `apply_event` as a no-op for now (the TUI integration plan will wire it properly).

Write unit tests covering:
- Register succeeds within limits
- Register fails when max_total exceeded
- Register fails when max_depth exceeded
- update_status changes info
- list_all returns all registered
- children_of returns correct children
- root_agents returns only parentless entries
- cancel_agent sets status to Killed
- create_child_token creates proper hierarchy
  </action>
  <verify>
    `cargo test --lib orchestration` passes. `cargo check` passes with no warnings (allow dead_code if needed temporarily for methods not yet called).
  </verify>
  <done>SubAgentManager compiles, all registry operations work, unit tests pass for register/status/query/cancel/depth-limit flows.</done>
</task>

</tasks>

<verification>
- `cargo check` passes with no errors
- `cargo test --lib orchestration` passes all unit tests
- `src/orchestration/types.rs` exports SubAgentId, SubAgentKind, SubAgentStatus, SubAgentInfo, SubAgentResult
- `src/orchestration/manager.rs` exports SubAgentManager with register/status/query/cancel/shutdown methods
- Cargo.toml contains tokio-util and uuid dependencies
- `src/lib.rs` contains `pub mod orchestration`
</verification>

<success_criteria>
The orchestration module foundation is complete: types compile with Serialize, SubAgentManager provides thread-safe registry operations with depth/count limits and CancellationToken hierarchy, and all unit tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/05-sub-agent-orchestration/05-01-SUMMARY.md`
</output>
