---
phase: 02-core-agent-loop-basic-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/lib.rs
  - src/error.rs
  - src/agent/mod.rs
  - src/agent/logging.rs
autonomous: true

must_haves:
  truths:
    - "All new dependencies (genai, chrono, futures, tokio signal) compile successfully"
    - "The agent module exists and is wired into the crate"
    - "JSONL session logger can create timestamped log files and write structured events"
  artifacts:
    - path: "Cargo.toml"
      provides: "New dependencies for Phase 2"
      contains: "genai"
    - path: "src/agent/mod.rs"
      provides: "Agent module declaration with submodule re-exports"
    - path: "src/agent/logging.rs"
      provides: "SessionLogger with JSONL event writing"
      min_lines: 80
    - path: "src/error.rs"
      provides: "AgentError enum for Phase 2 error types"
      contains: "AgentError"
  key_links:
    - from: "src/lib.rs"
      to: "src/agent/mod.rs"
      via: "pub mod agent"
      pattern: "pub mod agent"
    - from: "src/agent/logging.rs"
      to: "serde_json"
      via: "JSONL serialization"
      pattern: "serde_json::to_writer"
---

<objective>
Add Phase 2 dependencies, create the agent module structure, define agent error types, and implement the JSONL session logger.

Purpose: Establish the foundation modules and dependencies that all subsequent Phase 2 plans build on. The session logger is the first concrete deliverable -- it writes structured events to timestamped JSONL files for full session replay.

Output: Compiling crate with genai/chrono/futures dependencies, agent module skeleton, AgentError type, and a working SessionLogger.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-agent-loop-basic-tools/02-CONTEXT.md
@.planning/phases/02-core-agent-loop-basic-tools/02-RESEARCH.md

# Existing source files that will be modified
@src/lib.rs
@src/error.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 2 dependencies and create agent module skeleton</name>
  <files>
    Cargo.toml
    src/lib.rs
    src/main.rs
    src/agent/mod.rs
    src/error.rs
  </files>
  <action>
**Cargo.toml changes:**
Add these dependencies:

```toml
# LLM client (Ollama + multi-provider) -- use from Git per user decision
genai = { git = "https://github.com/jeremychone/rust-genai.git", branch = "main" }

# Stream iteration for genai ChatStream
futures = "0.3"

# Timestamps for log filenames and log entries
chrono = "0.4"
```

Update tokio to add the "signal" feature:
```toml
tokio = { version = "1", features = ["process", "time", "fs", "rt-multi-thread", "macros", "io-util", "signal"] }
```

**src/agent/mod.rs:**
Create the agent module with submodule declarations:
```rust
pub mod logging;

// These will be added by subsequent plans:
// pub mod system_prompt;
// pub mod tools;
// pub mod agent_loop;
```

**src/lib.rs:**
Add `pub mod agent;` to the existing module list.

**src/main.rs:**
Add `mod agent;` to the existing module list.

**src/error.rs:**
Add an `AgentError` enum alongside the existing error types:
```rust
#[derive(Debug, thiserror::Error)]
pub enum AgentError {
    #[error("Ollama not reachable at {url}: {message}")]
    OllamaUnavailable { url: String, message: String },

    #[error("Model '{model}' not available in Ollama: {message}")]
    ModelNotAvailable { model: String, message: String },

    #[error("System prompt not found at {path}")]
    SystemPromptNotFound { path: PathBuf },

    #[error("LLM error: {0}")]
    LlmError(String),

    #[error("Tool execution error: {0}")]
    ToolError(String),

    #[error("Session logging error: {0}")]
    LoggingError(String),

    #[error("Context window full after {turns} turns")]
    ContextFull { turns: u64 },
}
```
  </action>
  <verify>
Run `cargo check` -- must compile with no errors. The new dependencies should download and the agent module should be found.
  </verify>
  <done>
Cargo.toml has genai (from git main branch), futures, chrono, and tokio signal feature. src/agent/mod.rs exists with logging submodule. src/lib.rs and src/main.rs reference the agent module. src/error.rs has AgentError enum. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JSONL session logger</name>
  <files>
    src/agent/logging.rs
  </files>
  <action>
Implement `SessionLogger` in `src/agent/logging.rs` that writes structured JSONL events to timestamped session files.

**Log directory:** Stored as a sibling of the workspace directory (per context decision: "Log files stored alongside the workspace directory, not inside it"). The log directory is `{workspace_parent}/.ouro-logs/`. For a workspace at `/home/user/agent-workspace`, logs go to `/home/user/.ouro-logs/`.

**Session file naming:** `session-{ISO8601}.jsonl` using chrono for formatting, e.g., `session-2026-02-04T10-30-00.jsonl` (colons replaced with dashes for filesystem safety).

**LogEntry enum** (tagged with `#[serde(tag = "event_type")]`):
- `session_start` -- timestamp, model, workspace path
- `assistant_text` -- timestamp, turn number, content text
- `tool_call` -- timestamp, turn number, call_id, fn_name, fn_arguments (as serde_json::Value)
- `tool_result` -- timestamp, turn number, call_id, fn_name, result string, optional error string
- `system_message` -- timestamp, content
- `error` -- timestamp, turn number, message
- `session_end` -- timestamp, total_turns, reason string

**SessionLogger struct:**
- `writer: BufWriter<std::fs::File>` -- buffered writer for efficiency
- `new(workspace_path: &Path) -> anyhow::Result<Self>` -- creates log dir, opens timestamped file
- `log_event(&mut self, event: &LogEntry) -> anyhow::Result<()>` -- serializes to JSON line, writes, flushes
- `log_path(&self) -> &Path` -- returns the path to the current log file (for startup messages)
- Convenience methods: `log_session_start(model, workspace)`, `log_session_end(total_turns, reason)`

Use `chrono::Utc::now()` for all timestamps, formatted as ISO 8601 with milliseconds (`%Y-%m-%dT%H:%M:%S%.3fZ`).

Use `serde_json::to_writer(&mut self.writer, event)?` followed by `self.writer.write_all(b"\n")?` and `self.writer.flush()?` for durability after each event.

**Important:** The logger uses synchronous `std::fs` (not tokio::fs) since writes are small, buffered, and flushing after each event. This avoids async complexity for a simple append-only pattern.
  </action>
  <verify>
Run `cargo check` -- must compile. Run `cargo test` -- all existing tests must still pass (no regressions). Write a quick unit test in the logging module that creates a SessionLogger with a tempdir workspace, logs a session_start event, and verifies the JSONL file was created and contains valid JSON.
  </verify>
  <done>
SessionLogger creates timestamped JSONL files in a sibling log directory. LogEntry enum covers all event types (session_start, assistant_text, tool_call, tool_result, system_message, error, session_end). Events are serialized as single JSON lines with flush-after-write durability. A unit test confirms file creation and valid JSONL output. `cargo check` and `cargo test` pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with all new dependencies
2. `cargo test` passes (existing tests + new logging tests)
3. src/agent/ directory exists with mod.rs and logging.rs
4. src/error.rs contains AgentError enum
5. Cargo.toml has genai (git), futures, chrono, and tokio signal feature
</verification>

<success_criteria>
The crate compiles with all Phase 2 dependencies. The agent module skeleton exists and is wired into both lib.rs and main.rs. The SessionLogger can create timestamped JSONL log files, write structured events, and flush after each write. AgentError covers the error cases needed by subsequent plans.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-agent-loop-basic-tools/02-01-SUMMARY.md`
</output>
