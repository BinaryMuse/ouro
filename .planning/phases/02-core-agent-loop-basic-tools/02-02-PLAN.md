---
phase: 02-core-agent-loop-basic-tools
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/agent/mod.rs
  - src/agent/system_prompt.rs
  - src/agent/tools.rs
autonomous: true

must_haves:
  truths:
    - "System prompt is built from SYSTEM_PROMPT.md wrapped with harness context (tools, workspace, constraints)"
    - "Three tool schemas (shell_exec, file_read, file_write) are defined with proper JSON schemas"
    - "Tool dispatch correctly routes calls to SafetyLayer (shell), tokio::fs (file read), and WorkspaceGuard-validated writes"
    - "Tool errors are returned as structured results (not panics) so the model can react"
  artifacts:
    - path: "src/agent/system_prompt.rs"
      provides: "System prompt loading from SYSTEM_PROMPT.md and wrapping with harness context"
      min_lines: 40
    - path: "src/agent/tools.rs"
      provides: "Tool schema definitions and dispatch function"
      min_lines: 100
  key_links:
    - from: "src/agent/tools.rs"
      to: "src/safety/mod.rs"
      via: "SafetyLayer::execute() for shell_exec tool"
      pattern: "safety\\.execute"
    - from: "src/agent/tools.rs"
      to: "src/safety/workspace.rs"
      via: "WorkspaceGuard::is_write_allowed() for file_write validation"
      pattern: "is_write_allowed"
    - from: "src/agent/system_prompt.rs"
      to: "SYSTEM_PROMPT.md"
      via: "tokio::fs::read_to_string on workspace path"
      pattern: "SYSTEM_PROMPT\\.md"
---

<objective>
Implement system prompt loading (with harness context wrapping) and the tool system (schema definitions and dispatch function).

Purpose: The system prompt tells the model what it can do and how; the tool dispatch connects the model's structured tool calls to actual implementations. These are the two halves that the agent loop (Plan 03) combines to run the autonomous conversation.

Output: system_prompt.rs that loads SYSTEM_PROMPT.md and wraps it with harness context. tools.rs with three tool schemas (shell_exec, file_read, file_write) and a dispatch function that routes calls through the safety layer.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-agent-loop-basic-tools/02-CONTEXT.md
@.planning/phases/02-core-agent-loop-basic-tools/02-RESEARCH.md
@.planning/phases/02-core-agent-loop-basic-tools/02-01-SUMMARY.md

# Key interfaces from Phase 1
@src/safety/mod.rs
@src/safety/workspace.rs
@src/exec/shell.rs
@src/config/schema.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: System prompt loading and wrapping</name>
  <files>
    src/agent/system_prompt.rs
    src/agent/mod.rs
  </files>
  <action>
Implement `src/agent/system_prompt.rs` with a function that loads the user's SYSTEM_PROMPT.md from the workspace and wraps it with harness context.

**Function signature:**
```rust
pub async fn build_system_prompt(
    workspace: &Path,
    model: &str,
    tool_descriptions: &str,
) -> anyhow::Result<String>
```

**Behavior:**
1. Read `{workspace}/SYSTEM_PROMPT.md` using `tokio::fs::read_to_string`
2. If file does not exist, return `AgentError::SystemPromptNotFound` with the expected path
3. Build the combined prompt by wrapping the user content with harness context:

```
You are an autonomous AI agent running in the Ouroboros research harness.

## Environment
- Model: {model}
- Workspace: {workspace} (you own this directory)
- Shell commands execute in the workspace directory

## Available Tools
{tool_descriptions}

## Constraints
- File writes are restricted to the workspace directory
- Shell commands are filtered against a security blocklist
- Shell commands have a configurable timeout
- Read access is unrestricted

## Your System Prompt
The following is your system prompt, provided by your operator:

---

{user_system_prompt_content}
```

4. Return the combined string

**Also:** Add `pub mod system_prompt;` to `src/agent/mod.rs`.

**Important:** The `tool_descriptions` parameter is a pre-formatted string describing available tools in human-readable form. This is separate from the JSON tool schemas (which go to genai's Tool interface). The system prompt text helps the model understand what tools are available even before it sees the formal schemas.
  </action>
  <verify>
Run `cargo check` -- must compile. Write a unit test that calls `build_system_prompt` with a tempdir containing a SYSTEM_PROMPT.md and verifies the output contains both the harness context and the user content. Also test the error case when SYSTEM_PROMPT.md is missing.
  </verify>
  <done>
`build_system_prompt()` loads SYSTEM_PROMPT.md from workspace, wraps it with harness context (model name, workspace path, tool descriptions, constraints), and returns the combined string. Missing file returns AgentError::SystemPromptNotFound. Tests confirm both happy path and error case.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tool schema definitions and dispatch</name>
  <files>
    src/agent/tools.rs
    src/agent/mod.rs
  </files>
  <action>
Implement `src/agent/tools.rs` with tool schema definitions and a dispatch function.

**Tool schemas function:**
```rust
pub fn define_tools() -> Vec<genai::chat::Tool>
```

Define three tools using `genai::chat::Tool::new()`:

1. **shell_exec** -- Execute a shell command in the workspace directory
   - Parameters: `command` (string, required) -- the shell command to execute
   - Description: explains that commands run in workspace dir, returns stdout/stderr/exit_code/timed_out

2. **file_read** -- Read the contents of a file
   - Parameters: `path` (string, required) -- file path, relative to workspace or absolute
   - Description: explains read access is unrestricted

3. **file_write** -- Write content to a file within the workspace
   - Parameters: `path` (string, required) -- file path relative to workspace root; `content` (string, required) -- content to write
   - Description: explains writes restricted to workspace directory

Use `serde_json::json!()` macro for JSON schemas (per research: "don't hand-roll JSON schema strings").

**Tool descriptions function** (for system prompt):
```rust
pub fn tool_descriptions() -> String
```
Returns a human-readable string listing all tools with their parameters and descriptions. This is used by `build_system_prompt` to embed tool info in the system prompt text.

**Dispatch function:**
```rust
pub async fn dispatch_tool_call(
    call: &genai::chat::ToolCall,
    safety: &SafetyLayer,
    workspace: &Path,
) -> String
```

**Dispatch behavior:**
- Match on `call.fn_name` (as_str)
- For `shell_exec`: Extract "command" from `call.fn_arguments`, call `safety.execute(command).await`, serialize the ExecResult to JSON string via `serde_json::to_string`. On error, return a JSON error object `{"error": "message"}`.
- For `file_read`: Extract "path" from `call.fn_arguments`. If path is relative, resolve against workspace. Use `tokio::fs::read_to_string`. On error (file not found, permission denied), return a structured error string `{"error": "..."}`.
- For `file_write`: Extract "path" and "content" from `call.fn_arguments`. Resolve path relative to workspace. Validate write is within workspace using `safety.workspace_root()` -- construct the full path, canonicalize the parent, and check it starts_with the workspace root (same logic as WorkspaceGuard). Create parent directories with `tokio::fs::create_dir_all` if needed. Write with `tokio::fs::write`. On success, return `{"written_bytes": N, "path": "..."}`. On error (outside workspace, I/O error), return `{"error": "..."}`.
- For unknown tool names: return `{"error": "Unknown tool: {name}"}`.

**Important decisions (from context):**
- Tool errors are returned as structured result strings, NOT as Rust errors. The model sees them in conversation and can react.
- Tool results are returned in full -- no truncation (Phase 3 handles context pressure).
- File read is unrestricted (can read outside workspace). File write is restricted to workspace.
- The dispatch function never panics or returns Err -- it always returns a String result (success or error JSON).

**Also:** Add `pub mod tools;` to `src/agent/mod.rs`.
  </action>
  <verify>
Run `cargo check` -- must compile. Run `cargo test` -- all tests pass. Write unit tests for `define_tools()` (verify 3 tools returned with correct names). Write integration-style tests for `dispatch_tool_call` covering: successful shell_exec, file_read of existing file, file_write within workspace, file_write outside workspace (should return error), and unknown tool name.
  </verify>
  <done>
Three tool schemas defined with proper JSON schemas. `tool_descriptions()` returns human-readable tool listing for system prompt. `dispatch_tool_call` routes shell_exec through SafetyLayer, file_read through tokio::fs, and file_write through workspace-validated tokio::fs::write. All tool errors return structured JSON strings (never panics). Tests cover happy paths and error cases. `cargo check` and `cargo test` pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes
2. `cargo test` passes (all existing + new tests)
3. `define_tools()` returns 3 tools: shell_exec, file_read, file_write
4. `build_system_prompt()` loads SYSTEM_PROMPT.md and wraps with harness context
5. `dispatch_tool_call` correctly routes to safety layer, fs read, and workspace-guarded write
6. Tool errors return structured JSON, never panic
</verification>

<success_criteria>
The system prompt loads SYSTEM_PROMPT.md from the workspace and wraps it with harness context including tool descriptions, model name, workspace path, and constraints. Three tool schemas are defined using genai's Tool type. The dispatch function routes tool calls to implementations and always returns structured results (success or error). All tool operations respect the safety layer from Phase 1.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-agent-loop-basic-tools/02-02-SUMMARY.md`
</output>
