---
phase: 06-extended-tools-discovery
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/agent/tools.rs
  - src/agent/system_prompt.rs
autonomous: true

must_haves:
  truths:
    - "define_tools returns 13 tools (9 existing + 4 new: web_fetch, web_search, sleep, flag_discovery)"
    - "dispatch_tool_call routes all 4 new tool names to their handler functions"
    - "tool_descriptions includes human-readable docs for all 4 new tools"
    - "System prompt includes discovery guidance telling the agent what qualifies as a discovery"
  artifacts:
    - path: "src/agent/tools.rs"
      provides: "Tool schemas, dispatch branches, and descriptions for web_fetch, web_search, sleep, flag_discovery"
      contains: "web_fetch"
    - path: "src/agent/system_prompt.rs"
      provides: "Discovery guidance section in harness-injected system prompt"
      contains: "discovery"
  key_links:
    - from: "src/agent/tools.rs"
      to: "src/agent/web_fetch.rs"
      via: "dispatch_tool_call match arm calls web_fetch::fetch_url"
      pattern: "web_fetch::fetch_url"
    - from: "src/agent/tools.rs"
      to: "src/agent/web_search.rs"
      via: "dispatch_tool_call match arm calls web_search rate_limited functions"
      pattern: "web_search::rate_limited"
    - from: "src/agent/tools.rs"
      to: "src/agent/discovery.rs"
      via: "dispatch_tool_call match arm calls discovery::append_discovery"
      pattern: "discovery::append_discovery"
    - from: "src/agent/tools.rs"
      to: "src/agent/sleep.rs"
      via: "dispatch_tool_call match arm calls sleep::parse_sleep_args"
      pattern: "sleep::parse_sleep_args"
---

<objective>
Wire all four new tools into the tool dispatch system (define_tools, dispatch_tool_call, tool_descriptions) and add discovery guidance to the system prompt.

Purpose: This is the central integration point. After this plan, the agent can call all 4 new tools and the model's system prompt teaches it about discoveries.
Output: tools.rs with 13 tools, system_prompt.rs with discovery guidance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-tools-discovery/06-CONTEXT.md
@.planning/phases/06-extended-tools-discovery/06-RESEARCH.md
@.planning/phases/06-extended-tools-discovery/06-01-SUMMARY.md
@.planning/phases/06-extended-tools-discovery/06-02-SUMMARY.md
@src/agent/tools.rs
@src/agent/system_prompt.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 new tool schemas and dispatch branches to tools.rs</name>
  <files>src/agent/tools.rs</files>
  <action>
1. Add imports at top of tools.rs:
   ```rust
   use crate::agent::web_fetch;
   use crate::agent::web_search;
   use crate::agent::discovery;
   use crate::agent::sleep;
   use crate::tui::event::AgentEvent;
   use tokio::sync::mpsc::UnboundedSender;
   ```

2. Add 4 new Tool schemas to `define_tools()` (after the existing 9):
   - `web_fetch`:
     ```
     Tool::new("web_fetch")
         .with_description("Fetch a web page by URL...")
         .with_schema(json!({
             "type": "object",
             "properties": {
                 "url": { "type": "string", "description": "The URL to fetch" },
                 "format": { "type": "string", "enum": ["markdown", "html"], "description": "Output format (default: markdown)" },
                 "max_length": { "type": "integer", "description": "Optional truncation limit in characters" }
             },
             "required": ["url"]
         }))
     ```
   - `web_search`:
     ```
     Tool::new("web_search")
         .with_description("Search the internet...")
         .with_schema(json!({
             "type": "object",
             "properties": {
                 "query": { "type": "string", "description": "The search query" },
                 "count": { "type": "integer", "description": "Number of results to return" },
                 "provider": { "type": "string", "enum": ["duckduckgo", "brave"], "description": "Search provider (default: duckduckgo)" }
             },
             "required": ["query", "count"]
         }))
     ```
   - `sleep`:
     ```
     Tool::new("sleep")
         .with_description("Pause the agent loop...")
         .with_schema(json!({
             "type": "object",
             "properties": {
                 "mode": { "type": "string", "enum": ["timer", "event", "manual"], "description": "Sleep mode" },
                 "duration_secs": { "type": "integer", "description": "Duration in seconds (timer mode)" },
                 "agent_id": { "type": "string", "description": "Agent ID to wait for (event mode)" }
             },
             "required": ["mode"]
         }))
     ```
   - `flag_discovery`:
     ```
     Tool::new("flag_discovery")
         .with_description("Flag a noteworthy finding...")
         .with_schema(json!({
             "type": "object",
             "properties": {
                 "title": { "type": "string", "description": "Short title of the discovery" },
                 "description": { "type": "string", "description": "Detailed description of what was found and why it matters" }
             },
             "required": ["title", "description"]
         }))
     ```

3. Update `dispatch_tool_call` signature to accept additional parameters for the new tools. The sleep tool needs a way to communicate sleep state back to the agent loop, and flag_discovery needs the event_tx. The cleanest approach: add `event_tx: Option<&UnboundedSender<AgentEvent>>` and `sleep_state_tx: Option<tokio::sync::mpsc::UnboundedSender<sleep::SleepState>>` parameters. However, to keep changes minimal, use a simpler approach:
   - Add `event_tx: Option<&UnboundedSender<AgentEvent>>` parameter to dispatch_tool_call
   - The sleep tool returns a JSON response immediately with the parsed SleepState serialized -- the agent loop (Plan 04) will check for sleep tool results and enter the sleep state machine. This avoids changing the dispatch signature significantly.
   - Actually, the simplest pattern: dispatch_tool_call already takes `config: Option<&AppConfig>`. Add one more parameter: `event_tx: Option<&UnboundedSender<AgentEvent>>`. The sleep tool just returns a JSON object with the sleep parameters; the agent loop interprets the response. No sleep_state_tx channel needed.

   Updated signature:
   ```rust
   pub async fn dispatch_tool_call(
       call: &genai::chat::ToolCall,
       safety: &SafetyLayer,
       workspace: &Path,
       manager: Option<&SubAgentManager>,
       config: Option<&AppConfig>,
       event_tx: Option<&UnboundedSender<AgentEvent>>,
   ) -> String
   ```

4. Add match arms in `dispatch_tool_call`:
   ```rust
   "web_fetch" => dispatch_web_fetch(call).await,
   "web_search" => dispatch_web_search(call, config).await,
   "sleep" => dispatch_sleep(call, config),
   "flag_discovery" => dispatch_flag_discovery(call, workspace, event_tx),
   ```

5. Implement the 4 dispatch helper functions:
   - `async fn dispatch_web_fetch(call: &ToolCall) -> String`:
     - Extract url (required), format (default "markdown"), max_length (optional)
     - Call `web_fetch::fetch_url(url, format, max_length).await`
   - `async fn dispatch_web_search(call: &ToolCall, config: Option<&AppConfig>) -> String`:
     - Extract query (required), count (required), provider (default "duckduckgo")
     - For "duckduckgo": call `web_search::rate_limited_ddg_search(query, count, config.ddg_rate_limit_secs).await`
     - For "brave": check `config.brave_api_key` is Some, call `web_search::rate_limited_brave_search(...)`, return error if no API key
     - If config is None, use hardcoded defaults (2.0s DDG rate limit)
   - `fn dispatch_sleep(call: &ToolCall, config: Option<&AppConfig>) -> String`:
     - Extract the raw fn_arguments and pass to `sleep::parse_sleep_args`
     - On success, return JSON `{"status": "sleep_requested", "mode": ..., "duration_secs": ..., "agent_id": ...}` -- the agent loop (Plan 04) will detect this special response from the "sleep" tool and enter the sleep state machine
     - On error, return JSON error string
   - `fn dispatch_flag_discovery(call: &ToolCall, workspace: &Path, event_tx: Option<&UnboundedSender<AgentEvent>>) -> String`:
     - Extract title (required), description (required)
     - Generate timestamp via `chrono::Utc::now().format(...)`
     - Create Discovery struct, call `discovery::append_discovery(workspace, &disc)`
     - If event_tx is Some, send `AgentEvent::Discovery { timestamp, content: format!("{title}: {description}") }`
     - Return JSON `{"status": "discovery_flagged", "title": title}`

6. Update `tool_descriptions()` to include all 4 new tools with the same markdown format as existing tools.

7. Update the module doc comment to reflect 13 tools (9 + 4).

8. Update all existing tests:
   - `define_tools_returns_nine_tools` -> `define_tools_returns_thirteen_tools` (assert 13)
   - `define_tools_has_correct_names` -> add the 4 new names
   - `tool_descriptions_contains_all_tools` -> add assertions for new tools
   - All `dispatch_tool_call` test calls need the new `event_tx: None` parameter
   - Add basic test: dispatch_flag_discovery with valid args stores a discovery
   - Add basic test: dispatch_sleep with valid timer args returns sleep_requested JSON

9. Update the agent_loop.rs call site for dispatch_tool_call to pass the new `event_tx` parameter. The call is on line ~521:
   ```rust
   dispatch_tool_call(call, safety, &config.workspace, Some(&manager), Some(config), event_tx.as_ref()).await;
   ```
   Note: `event_tx` is already available in agent_loop.rs as a local variable.
  </action>
  <verify>
`cargo check` compiles cleanly. `cargo test` passes -- particularly the updated tools.rs tests (13 tools, correct names, descriptions contain new tool names).
  </verify>
  <done>
define_tools returns 13 tools. dispatch_tool_call routes web_fetch, web_search, sleep, flag_discovery. All dispatch helpers implemented. Existing tests updated and passing. Agent loop call site updated with event_tx parameter.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add discovery guidance to system prompt</name>
  <files>src/agent/system_prompt.rs</files>
  <action>
1. In `build_system_prompt`, add a new section after "## Constraints" and before the session continuity section:
   ```
   ## Discoveries
   You can flag noteworthy findings using the flag_discovery tool. A "discovery" is anything
   you judge would be useful to surface to the user -- interesting patterns in data,
   unexpected results, useful resources found during web searches, insights from exploration,
   or anything that helps document what you've learned. Use a clear, descriptive title and
   provide enough context in the description that the user understands the finding without
   reading the full conversation history. Discoveries persist across session restarts and
   are visible in the TUI discoveries panel.
   ```

2. Update the existing tests:
   - `build_system_prompt_includes_harness_context_and_user_content`: add assertion that result contains "Discoveries" and "flag_discovery"
   - The continuity test should still pass since the new section is before session continuity
  </action>
  <verify>
`cargo test -- system_prompt` passes. The prompt contains discovery guidance text.
  </verify>
  <done>
System prompt includes discovery guidance section teaching the agent what qualifies as a discovery and how to use flag_discovery.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` compiles cleanly
2. `cargo test` passes all tests including updated tools tests
3. `define_tools(None)` returns exactly 13 tools with correct names
4. `dispatch_tool_call` handles web_fetch, web_search, sleep, flag_discovery
5. `tool_descriptions()` documents all 13 tools
6. System prompt contains discovery guidance
7. Agent loop dispatch call passes event_tx
</verification>

<success_criteria>
- 13 tool schemas defined with proper JSON schema descriptions
- Dispatch routes all 4 new tool names to handlers
- web_fetch dispatch calls web_fetch::fetch_url
- web_search dispatch uses config for provider selection and rate limits
- sleep dispatch returns sleep_requested JSON for agent loop consumption
- flag_discovery dispatch persists to disk and emits AgentEvent::Discovery
- System prompt includes discovery guidance
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-tools-discovery/06-03-SUMMARY.md`
</output>
