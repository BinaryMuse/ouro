---
phase: 06-extended-tools-discovery
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/agent/agent_loop.rs
  - src/tui/event.rs
  - src/tui/app_state.rs
  - src/tui/tabs/discoveries_tab.rs
  - src/tui/widgets/status_bar.rs
autonomous: true

must_haves:
  truths:
    - "When the agent calls the sleep tool, the agent loop blocks between turns until the wake condition is met (timer/event/manual)"
    - "Sleep countdown or status is visible in the TUI status bar"
    - "A Sleeping state appears in the TUI and the agent does NOT make LLM calls while sleeping"
    - "Discoveries in the TUI show title and description (not just content string)"
    - "User can manually resume a sleeping agent from the TUI (same as existing pause: TUI sets a flag)"
    - "Agent receives a wake notification system message when sleep ends"
  artifacts:
    - path: "src/agent/agent_loop.rs"
      provides: "Sleep state machine integration between turns, wake notification injection"
      contains: "SleepState"
    - path: "src/tui/event.rs"
      provides: "AgentState::Sleeping variant, enhanced Discovery event with title+description"
      contains: "Sleeping"
    - path: "src/tui/app_state.rs"
      provides: "Sleep tracking fields, enhanced discovery data model"
      contains: "sleep_state"
    - path: "src/tui/tabs/discoveries_tab.rs"
      provides: "Two-line discovery rendering (title + description)"
      contains: "title"
    - path: "src/tui/widgets/status_bar.rs"
      provides: "Sleep countdown display in status bar line 1"
      contains: "Sleeping"
  key_links:
    - from: "src/agent/agent_loop.rs"
      to: "src/agent/sleep.rs"
      via: "Import SleepState, check after sleep tool dispatch, block in loop"
      pattern: "sleep::SleepState"
    - from: "src/tui/widgets/status_bar.rs"
      to: "src/tui/app_state.rs"
      via: "Read sleep_display_text from AppState for status bar"
      pattern: "sleep_display"
    - from: "src/tui/app_state.rs"
      to: "src/tui/event.rs"
      via: "Match AgentState::Sleeping variant in apply_event"
      pattern: "AgentState::Sleeping"
---

<objective>
Integrate the sleep state machine into the agent loop and enhance the TUI with sleep status display and improved discovery rendering.

Purpose: After this plan, the agent can actually sleep (the loop blocks), the TUI shows sleep status, and discoveries display with title + description. This completes the runtime behavior for all 4 Phase 6 tools.
Output: Agent loop with sleep integration, TUI with sleep status bar and enhanced discoveries tab.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-tools-discovery/06-CONTEXT.md
@.planning/phases/06-extended-tools-discovery/06-RESEARCH.md
@.planning/phases/06-extended-tools-discovery/06-01-SUMMARY.md
@.planning/phases/06-extended-tools-discovery/06-02-SUMMARY.md
@src/agent/agent_loop.rs
@src/tui/event.rs
@src/tui/app_state.rs
@src/tui/tabs/discoveries_tab.rs
@src/tui/widgets/status_bar.rs
@src/tui/input.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Sleeping state to TUI events and enhance discovery data model</name>
  <files>src/tui/event.rs, src/tui/app_state.rs, src/tui/tabs/discoveries_tab.rs, src/tui/widgets/status_bar.rs</files>
  <action>
1. In `src/tui/event.rs`:
   - Add `Sleeping` variant to `AgentState` enum:
     ```rust
     /// Agent is sleeping (self-initiated pause).
     Sleeping,
     ```
   - Update `AgentState::Display` impl to handle Sleeping -> "Sleeping"
   - Update the `AgentEvent::Discovery` variant to carry title and description separately:
     ```rust
     Discovery {
         timestamp: String,
         title: String,
         description: String,
     },
     ```

2. In `src/tui/app_state.rs`:
   - Change `discoveries` field from `Vec<(String, String)>` to `Vec<(String, String, String)>` (timestamp, title, description)
   - Add sleep display field:
     ```rust
     /// Human-readable sleep status for the status bar (empty when not sleeping).
     pub sleep_display_text: String,
     ```
   - Update `apply_event` for the new `Discovery` variant:
     ```rust
     AgentEvent::Discovery { timestamp, title, description } => {
         self.discoveries.push((timestamp, title, description));
     }
     ```
   - Update `apply_event` for `StateChanged` to clear sleep_display_text when state is not Sleeping
   - Add a new method `pub fn update_sleep_display(&mut self, text: &str)` that sets sleep_display_text -- called from the runner's render tick when sleep state is active
   - Initialize `sleep_display_text` to empty string in `AppState::new()`
   - Update the agent_state_display test to include Sleeping

3. In `src/tui/tabs/discoveries_tab.rs`:
   - Update rendering to use the 3-tuple (timestamp, title, description):
     - Each discovery renders as two lines:
       - Line 1: `[timestamp] title` in bold/white
       - Line 2: `  description` in dim/gray, indented 2 spaces
     - Use `ListItem::new(vec![line1, line2])` for multi-line items
   - Update tests to use 3-tuples in `AgentEvent::Discovery`

4. In `src/tui/widgets/status_bar.rs`:
   - Add `Sleeping` to `agent_state_style`: use `Color::Magenta` (distinct from Yellow/Thinking, Red/Paused)
   - After the agent state span in line 1, if `state.sleep_display_text` is non-empty, insert it:
     ```rust
     if !state.sleep_display_text.is_empty() {
         line1_spans.push(sep.clone());
         line1_spans.push(Span::styled(
             state.sleep_display_text.clone(),
             Style::default().fg(Color::Magenta),
         ));
     }
     ```
   - Add keybind hint for "r: resume" when state is Sleeping (in line 2)
   - Update tests to verify Sleeping state renders correctly
  </action>
  <verify>
`cargo check` compiles. `cargo test -- app_state` and `cargo test -- discoveries_tab` and `cargo test -- status_bar` all pass.
  </verify>
  <done>
AgentState::Sleeping exists. Discovery events carry title+description. AppState tracks sleep display text. Discoveries tab renders title and description on two lines. Status bar shows sleep countdown when sleeping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate sleep state machine into agent loop</name>
  <files>src/agent/agent_loop.rs</files>
  <action>
1. Add imports:
   ```rust
   use crate::agent::sleep::{SleepState, SleepMode};
   use std::sync::atomic::AtomicBool as StdAtomicBool;
   ```

2. Add a mutable `Option<SleepState>` variable in the main loop state section (near `let mut turn: u64 = 0`):
   ```rust
   let mut pending_sleep: Option<SleepState> = None;
   ```

3. After tool call dispatch (inside the `for call in &captured_tool_calls` loop), detect the sleep tool response:
   ```rust
   // After dispatch_tool_call returns `result`:
   if call.fn_name == "sleep" {
       // Check if the result indicates a sleep request
       if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&result) {
           if parsed.get("status").and_then(|s| s.as_str()) == Some("sleep_requested") {
               // Parse the sleep state from the dispatch response
               let max_dur = config.max_sleep_duration_secs;
               if let Ok(sleep_state) = sleep::parse_sleep_args(&call.fn_arguments, max_dur) {
                   pending_sleep = Some(sleep_state);
               }
           }
       }
   }
   ```

4. After the tool dispatch loop completes and before the context evaluation section, add the sleep state machine check (right after the `send_event(AgentEvent::StateChanged(AgentState::Idle))` and counters update):
   ```rust
   // -- Check for pending sleep (agent-initiated via sleep tool)
   if let Some(ref mut sleep_state) = pending_sleep {
       if sleep_state.active {
           // Emit Sleeping state
           send_event(AgentEvent::StateChanged(AgentState::Sleeping));

           // Log sleep start
           let sleep_desc = sleep_state.remaining_display();
           logger.log_event(&LogEntry::SystemMessage {
               timestamp: now_iso_timestamp(),
               content: format!("[Agent sleeping: {sleep_desc}]"),
           })?;

           // Sleep loop -- blocks between turns
           let wake_reason;
           loop {
               tokio::time::sleep(Duration::from_millis(500)).await;

               // Check shutdown
               if shutdown.load(Ordering::SeqCst) {
                   wake_reason = "shutdown".to_string();
                   break;
               }

               // Check max duration
               if sleep_state.is_expired() {
                   wake_reason = "max_duration_exceeded".to_string();
                   break;
               }

               // Check mode-specific wake conditions
               match &sleep_state.mode {
                   SleepMode::Timer(d) => {
                       if sleep_state.elapsed() >= *d {
                           wake_reason = "timer_expired".to_string();
                           break;
                       }
                   }
                   SleepMode::Event { agent_id } => {
                       if let Some(info) = manager.get_status(agent_id) {
                           let status_str = serde_json::to_string(&info.status).unwrap_or_default();
                           if status_str.contains("Completed") || status_str.contains("Failed") || status_str.contains("Killed") {
                               wake_reason = format!("agent_{agent_id}_{status_str}");
                               break;
                           }
                       } else {
                           // Agent not found -- wake immediately
                           wake_reason = format!("agent_{agent_id}_not_found");
                           break;
                       }
                   }
                   SleepMode::Manual => {
                       // Manual mode: check if user resumed via TUI (pause_flag toggled)
                       // The TUI resume action clears the pause flag, which we repurpose here
                       if let Some(ref pf) = pause_flag {
                           if !pf.load(Ordering::SeqCst) {
                               // Not paused = user resumed
                               // But we need a separate "sleep resume" mechanism.
                               // Use the existing pause flag: when sleeping manually,
                               // we set pause_flag to true on sleep entry, and the
                               // TUI 'r'/'p' key clears it.
                           }
                       }
                       // For manual mode, we only break on shutdown or max_duration.
                       // The TUI resume signal is handled by checking pause_flag.
                       // Actually: reuse pause_flag -- set it on manual sleep entry,
                       // TUI clears it on resume, we detect the clear here.
                   }
               }

               // For manual mode: if pause_flag was set by us and is now cleared, user resumed
               if matches!(sleep_state.mode, SleepMode::Manual) {
                   if let Some(ref pf) = pause_flag {
                       if !pf.load(Ordering::SeqCst) {
                           wake_reason = "user_resumed".to_string();
                           break;
                       }
                   }
               }
           }

           // For manual mode: ensure pause_flag is cleared
           if matches!(sleep_state.mode, SleepMode::Manual) {
               if let Some(ref pf) = pause_flag {
                   pf.store(false, Ordering::SeqCst);
               }
           }

           sleep_state.wake(&wake_reason);

           // Inject wake notification as system message
           let elapsed_secs = sleep_state.elapsed().as_secs_f64();
           let wake_msg = format!(
               "[Sleep ended. Reason: {wake_reason}. You slept for {elapsed_secs:.1}s]"
           );
           chat_req = chat_req.append_message(ChatMessage::system(&wake_msg));
           context_manager.add_chars(wake_msg.len());

           // Log wake event
           logger.log_event(&LogEntry::SystemMessage {
               timestamp: now_iso_timestamp(),
               content: wake_msg,
           })?;

           // Clear pending sleep
           pending_sleep = None;

           // Restore Idle state
           send_event(AgentEvent::StateChanged(AgentState::Idle));
       }
   }
   ```

   Note on manual mode: For manual sleep, set the `pause_flag` to true when entering manual sleep. The TUI's existing 'p' key (resume) clears it, which wakes the agent. This reuses the existing mechanism cleanly. Add at manual sleep entry:
   ```rust
   if matches!(sleep_state.mode, SleepMode::Manual) {
       if let Some(ref pf) = pause_flag {
           pf.store(true, Ordering::SeqCst);
       }
   }
   ```

5. Ensure the turn counter does NOT increment during sleep (the sleep block is after the turn increment, so this is naturally correct -- sleep happens between turns, not during).

6. Update existing agent_loop tests if needed (the dispatch_tool_call signature now has event_tx parameter -- this was handled in Plan 03).
  </action>
  <verify>
`cargo check` compiles. `cargo test` passes all tests. `cargo clippy -- -D warnings` passes (enforced from Phase 5).
  </verify>
  <done>
Agent loop detects sleep tool responses and enters the sleep state machine. Timer/event/manual modes all wake correctly. Wake notification injected as system message. Turn counter does not increment during sleep. Manual mode reuses pause_flag for TUI resume.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build verification</name>
  <files>(no new files)</files>
  <action>
Run the full verification suite:
1. `cargo clippy -- -D warnings` -- all warnings are errors
2. `cargo test` -- all tests pass
3. `cargo build --release` -- release build succeeds

If any failures, fix them. Common issues:
- Unused imports from new modules
- Dead code warnings on new public functions not yet called externally
- Missing `#[allow(dead_code)]` on types used only in specific code paths
- Borrow checker issues with event_tx reference in dispatch

Address all issues until all three commands pass cleanly.
  </action>
  <verify>
All three commands succeed with exit code 0. No warnings from clippy.
  </verify>
  <done>
Clean build: clippy passes with -D warnings, all tests pass, release build succeeds. Phase 6 code is complete and compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `cargo clippy -- -D warnings` passes
2. `cargo test` passes all tests (existing + new)
3. `cargo build --release` succeeds
4. AgentState::Sleeping variant exists and renders in status bar
5. Discovery events carry title + description; tab renders both
6. Sleep state machine blocks the agent loop and injects wake notification
7. Manual sleep reuses pause_flag for TUI resume
</verification>

<success_criteria>
- Agent loop blocks on sleep tool and resumes correctly for all 3 modes
- Sleep status visible in TUI status bar (Sleeping state + countdown/description)
- Discoveries show title and description in TUI tab (newest first)
- Wake notification injected as system message with elapsed time and reason
- Clean clippy + test + release build
- No orphan processes or resource leaks from sleep mechanism
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-tools-discovery/06-04-SUMMARY.md`
</output>
