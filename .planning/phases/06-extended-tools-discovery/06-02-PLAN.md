---
phase: 06-extended-tools-discovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agent/discovery.rs
  - src/agent/sleep.rs
  - src/agent/mod.rs
autonomous: true

must_haves:
  truths:
    - "Discovery module can append a discovery to a JSONL file and load all discoveries from disk"
    - "Sleep module defines the sleep state machine types (SleepState, SleepMode) for timer/event/manual modes"
    - "Both modules compile as standalone units with no dependency on tools.rs dispatch"
  artifacts:
    - path: "src/agent/discovery.rs"
      provides: "Discovery struct, append_discovery(), load_discoveries() for JSONL persistence"
      contains: "pub fn append_discovery"
    - path: "src/agent/sleep.rs"
      provides: "SleepState, SleepMode enums/structs for agent-initiated sleep"
      contains: "pub struct SleepState"
  key_links:
    - from: "src/agent/discovery.rs"
      to: "workspace/.ouro-discoveries.jsonl"
      via: "BufWriter append with flush"
      pattern: "OpenOptions.*append"
    - from: "src/agent/sleep.rs"
      to: "tokio::time"
      via: "Duration for timer mode and Instant for elapsed tracking"
      pattern: "SleepMode"
---

<objective>
Create the standalone discovery persistence module and sleep state machine types.

Purpose: Provides the data structures and persistence logic that Plan 03 (tool dispatch wiring) and Plan 04 (agent loop integration) will consume. These modules are standalone -- no wiring into the agent loop or tool dispatch happens here.
Output: Two new agent modules (discovery.rs, sleep.rs) with complete internal logic and unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-extended-tools-discovery/06-CONTEXT.md
@.planning/phases/06-extended-tools-discovery/06-RESEARCH.md
@src/agent/mod.rs
@src/agent/logging.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create discovery persistence module</name>
  <files>src/agent/discovery.rs, src/agent/mod.rs</files>
  <action>
1. Create `src/agent/discovery.rs`:
   - Define the Discovery struct:
     ```rust
     #[derive(Debug, Clone, Serialize, Deserialize)]
     pub struct Discovery {
         pub timestamp: String,
         pub title: String,
         pub description: String,
     }
     ```
   - Implement `pub fn discovery_file_path(workspace: &Path) -> PathBuf` returning `workspace.join(".ouro-discoveries.jsonl")`
   - Implement `pub fn append_discovery(workspace: &Path, discovery: &Discovery) -> Result<(), String>`:
     - Opens file with `OpenOptions::new().create(true).append(true)`
     - Wraps in `BufWriter`
     - Serializes discovery as JSON, writes newline, flushes
     - Returns `Err(String)` on any I/O or serde error (matching codebase error-as-string convention)
   - Implement `pub fn load_discoveries(workspace: &Path) -> Vec<Discovery>`:
     - Reads the JSONL file, returns empty Vec if file doesn't exist
     - Parses each line with `serde_json::from_str`, skips unparseable lines (lenient reader)
     - Returns Vec of valid discoveries in file order

2. Add unit tests in the same file:
   - Test append + load roundtrip (using tempdir)
   - Test load from nonexistent file returns empty Vec
   - Test lenient parsing skips corrupt lines
   - Test multiple appends produce correct JSONL

3. In `src/agent/mod.rs`, add:
   ```rust
   pub mod discovery;
   ```

Note: The module depends only on `serde`, `serde_json`, and `std::io/fs` -- all already available. No new Cargo deps needed for this module.
  </action>
  <verify>
`cargo test -- discovery` passes all unit tests. `cargo check` compiles cleanly.
  </verify>
  <done>
discovery.rs exports Discovery struct, append_discovery, load_discoveries. JSONL roundtrip tested. Lenient parsing handles corrupt lines.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sleep state machine module</name>
  <files>src/agent/sleep.rs, src/agent/mod.rs</files>
  <action>
1. Create `src/agent/sleep.rs`:
   - Define the sleep mode enum:
     ```rust
     #[derive(Debug, Clone)]
     pub enum SleepMode {
         /// Sleep for a fixed duration.
         Timer(Duration),
         /// Sleep until a specific sub-agent/process completes.
         Event { agent_id: String },
         /// Sleep until user manually resumes from TUI.
         Manual,
     }
     ```
   - Define the sleep state struct:
     ```rust
     #[derive(Debug, Clone)]
     pub struct SleepState {
         pub active: bool,
         pub mode: SleepMode,
         pub started_at: std::time::Instant,
         pub max_duration: Duration,
         pub wake_reason: Option<String>,
     }
     ```
   - Implement `impl SleepState`:
     - `pub fn new(mode: SleepMode, max_duration: Duration) -> Self` -- sets active=true, started_at=Instant::now(), wake_reason=None
     - `pub fn elapsed(&self) -> Duration` -- returns started_at.elapsed()
     - `pub fn remaining_display(&self) -> String` -- returns human-readable remaining time string for timer mode (e.g., "2m 34s"), "Waiting: agent {id}" for event mode, "Manual pause" for manual mode
     - `pub fn is_expired(&self) -> bool` -- checks if elapsed >= max_duration
     - `pub fn wake(&mut self, reason: &str)` -- sets active=false, wake_reason=Some(reason)

2. Implement `pub fn parse_sleep_args(args: &serde_json::Value, max_sleep_duration_secs: u64) -> Result<SleepState, String>`:
   - Extracts "mode" field: "timer" | "event" | "manual"
   - For "timer": extracts "duration_secs" (required, must be > 0)
   - For "event": extracts "agent_id" (required)
   - For "manual": no additional args
   - Clamps effective duration to min(requested, max_sleep_duration_secs)
   - Returns SleepState ready to use, or error string if invalid args

3. Add unit tests:
   - Test SleepState::new sets active=true
   - Test remaining_display for timer mode
   - Test remaining_display for event mode
   - Test remaining_display for manual mode
   - Test is_expired returns true after max_duration (use a short duration and sleep)
   - Test parse_sleep_args with valid timer args
   - Test parse_sleep_args with valid event args
   - Test parse_sleep_args with missing required fields returns error
   - Test parse_sleep_args clamps to max duration

4. In `src/agent/mod.rs`, add:
   ```rust
   pub mod sleep;
   ```
  </action>
  <verify>
`cargo test -- sleep` passes all unit tests. `cargo check` compiles cleanly.
  </verify>
  <done>
sleep.rs exports SleepMode, SleepState, and parse_sleep_args. Timer/event/manual modes defined. Duration clamping works. All unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` compiles cleanly with both new modules
2. `cargo test -- discovery` passes all discovery unit tests
3. `cargo test -- sleep` passes all sleep unit tests
4. `src/agent/discovery.rs` exists with pub functions for append and load
5. `src/agent/sleep.rs` exists with SleepState, SleepMode, and parse_sleep_args
</verification>

<success_criteria>
- Discovery JSONL persistence roundtrips correctly (write then read)
- Lenient JSONL reader skips corrupt lines without error
- Sleep state machine types compile with all three modes
- Sleep arg parser validates inputs and clamps durations
- Both modules registered in agent/mod.rs
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-extended-tools-discovery/06-02-SUMMARY.md`
</output>
